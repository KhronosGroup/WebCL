<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WebCL Specification</title>
  <link rel="stylesheet" type="text/css" href="http://www.khronos.org/registry/webcl/resources/Khronos-WD.css">
  <script src="http://www.khronos.org/registry/webcl/resources/jquery-1.3.2.min.js" type="text/javascript"></script>
  <script src="http://www.khronos.org/registry/webcl/resources/generateTOC.js" type="text/javascript"></script>
  <script src="http://www.khronos.org/registry/webcl/resources/preprocessHTML.js" type="text/javascript"></script>
</head>

<body>

    <!--begin-logo-->
    <div class="head">
      <p>
        <a href="http://khronos.org/">
          <img alt="Khronos" src="http://www.khronos.org/registry/webcl/resources/KhronosGroup-3D.png" height="60" width="220">
        </a>
      </p>
    </div>
    <div class="head">
      <p>
        <a href="http://www.khronos.org/webcl/">
          <img alt="WebCL logo" src="http://www.khronos.org/registry/webcl/resources/WebCL_logo.png" width="150" height="69">
        </a>
      </p>
    </div>
    <!--end-logo-->

    <h1>WebCL Specification</h1>
    <h2 class="no-toc">Editor's Draft, 19 June 2014</h2>
    <dl>
      <dt>This version:
      </dt><dd>
        <a href="http://www.khronos.org/registry/webcl/specs/latest/1.0/">
          http://www.khronos.org/registry/webcl/specs/latest/1.0/
        </a>
      </dd>
      <dt>Latest version:
      </dt><dd>
        <a href="http://www.khronos.org/registry/webcl/specs/latest/1.0/">
          http://www.khronos.org/registry/webcl/specs/latest/1.0/
        </a>
      </dd>
      <dt>Previous version:
      </dt><dd>
        <a href="http://www.khronos.org/registry/webcl/specs/1.0.0/">
          http://www.khronos.org/registry/webcl/specs/1.0.0/
        </a>
      </dd>
      <dt>Editors:</dt>
      <dd>
        <a href="mailto:tomi.aarnio@nokia.com">Tomi Aarnio</a>
        (<a href="http://webcl.nokiaresearch.com/">Nokia Research</a>)
      </dd>
      <dd>
        <a href="mailto:mikael.sevenier@amd.com">Mika&euml;l Bourges-S&eacute;venier</a>
        (<a href="http://www.amd.com/">Advanced Micro Devices, Inc.</a>)
      </dd>
    </dl>

    <p><span style="font-size: x-small; font-style: oblique">Copyright © 2014 Khronos Group</span></p>

    <hr>

    <h2 class="no-toc">Abstract</h2>
    <p>
      This specification defines WebCL (Web Computing Language).
      WebCL is a JavaScript binding to the Khronos OpenCL standard for
      heterogeneous parallel computing. It enables web applications to
      harness GPU and multi-core CPU parallel processing from within a
      Web browser, enabling significant acceleration of
      computationally intensive applications, such as image and video
      processing, data visualization, and 3D games.
    </p>

    <h2 class="no-toc">Status of this document</h2>

    <!--begin-status-->
    <p>
      This document is an Editor's Draft.  Do not cite this document as anything other than work in
      progress.  Public discussion of this document is welcome on the
      (<a href="https://www.khronos.org/webcl/public-mailing-list/archives/">archived</a>) WebCL
      mailing list <a href="mailto:public_webcl@khronos.org">public_webcl@khronos.org</a> (see
      <a href="http://www.khronos.org/webcl/public-mailing-list/">instructions</a>).
    </p>
    <!--end-status-->

    <h2 class="no-toc">Contents</h2>
    <div id="toc"><ul class="toc">
    </ul></div>

<!-- ======================================================================================================= -->

    <h2>Introduction</h2>

    <p>
      With the popularity of web-centric platforms, there is a need to leverage high-performance
      parallel processing to accelerate compute-intensive web applications.  Such applications
      include, for example, data visualization, image and video processing, 3D gaming, computational
      photography, computer vision, and cryptography.  By providing application developers with a
      standardized JavaScript API and a portable kernel programming language, WebCL enables parallel
      computing on heterogeneous multicore hardware across a breadth of devices, including mobile,
      desktop, and server.  The WebCL API and kernel language are designed to be substantially
      similar to those of OpenCL (Open Computing Language), and implementable on top of a conformant
      OpenCL driver.
    </p>

<!-- ======================================================================================================= -->

    <h2>Conventions</h2>

    <h3>Basic types</h3>

    <p>The following basic types are used in this document.</p>

<pre class="idl">
typedef boolean             CLboolean;
typedef long                CLint;      // 32-bit signed integer
typedef long long           CLlong;     // 64-bit signed integer
typedef unsigned long       CLuint;     // 32-bit unsigned integer
typedef unsigned long long  CLulong;    // 52-bit unsigned integer
typedef unsigned long       CLenum;     // Used for enumerated types, such as WebCL.DEVICE_TYPE_GPU
</pre>

    <p>
      The implementation of any WebCL function that accepts numeric values as input must ensure that
      no undefined behavior will occur if the input value is outside of the specified numeric range.
      Where necessary, the implementation may fit the incoming JavaScript number into the valid
      range using a clamp or modulo operator, or alternatively throw an exception.  Note that the
      range of `CLulong` is limited to 52 bits, due to the lack of 64-bit integers in JavaScript.
    </p>

    <h3><a id="WEBCLEXCEPTION">Exceptions</a></h3>

    <p>
      WebCL methods throw exceptions instead of returning error codes as return values as in OpenCL.
      Exceptions that may be thrown by each method are listed in that method's documentation.
      Additionally, almost all methods may throw `OUT_OF_RESOURCES`, `OUT_OF_HOST_MEMORY`, or the
      WebCL-specific `WEBCL_IMPLEMENTATION_FAILURE`, so these are not listed separately.
      Furthermore, calling any function (except `release`) on an object that has been released, will
      throw <code>INVALID_<i>TYPE</i></code>, where <i>`TYPE`</i> is `CONTEXT`, `COMMAND_QUEUE`,
      `MEM_OBJECT`, `SAMPLER`, `PROGRAM`, `KERNEL`, or `EVENT`.  These exceptions are also not
      listed separately in the method descriptions.
    </p>

<pre class="idl">
exception <dfn>WebCLException</dfn> : DOMException {
  DOMString name;              // A string representation of the numeric error code, e.g. "INVALID_VALUE"
  DOMString? message;          // An implementation-specific description of what caused the exception
};
</pre>

    <p>
      Both the `name` and `message` fields are present in any
      WebCLException thrown by the implementation, but the message may
      be `null`.
    </p>

    <h3><a id="RELEASE">Resource management</a></h3>

    <p>
      Each dynamically created WebCL object has a `release` method
      that releases the resources consumed by that object.  This does
      not cause the object to be deleted or garbage collected; it will
      remain in place, but trying to use it will cause an exception.
      Trying to release an object that has already been released will
      be silently ignored.
    </p>

    <p>
      For convenience, the WebCL and WebCLContext classes contain an
      additional `releaseAll` function, which releases the context(s),
      as well as all other WebCL objects created from them.  The usage
      and behavior of the release methods are illustrated in the
      example below.
    </p>

<pre class="example">
  var ctx1 = webcl.createContext(...);
  var ctx2 = webcl.createContext(...);
  var ctx3 = webcl.createContext(...);
  var A = ctx1.createBuffer(...);
  var B = ctx2.createBuffer(...);
  ctx1.release();                    // releases ctx1, but not buffer A
  ctx2.releaseAll();                 // releases ctx2 and buffer B
  A.release();                       // releases buffer A 
  B.release();                       // does nothing: B is already released
  var C = ctx1.createBuffer(...);    // EXCEPTION: ctx1 is no longer valid
  webcl.releaseAll();                // releases ctx3
</pre>

    <p>
      Applications are strongly recommended to explicitly release all
      WebCL objects as soon as they are no longer needed, instead of
      relying on the JavaScript garbage collector.  This is necessary
      because garbage collectors typically do not give any guarantees
      on when (or indeed if) they will reclaim the objects that are no
      longer in scope.
    </p>

    <p>
      When the global `document` object goes out of scope, the WebCL
      implementation must implicitly call `release` on all remaining
      WebCL objects.
    </p>

    <h3><a id="CONCURRENCY">Concurrency</a></h3>

    <p>
      Depending on the implementation, WebCL operations may be running
      concurrently with JavaScript.  In particular, it may be possible
      for the application to modify an ArrayBuffer while it's being
      asynchronously copied to/from a WebCLMemoryObject.  To avoid
      corrupting the contents of either buffer, applications should
      not modify an ArrayBuffer that has been enqueued for async
      read/write, until the relevant WebCL command queue has finished.
    </p>

    <h3><a id="WEBCLCALLBACK">Callbacks</a></h3>

    <p>
      WebCL allows certain long-running functions to be executed either synchronously or
      asynchronously.  The asynchronous mode is used if a user-defined callback function is given as
      an argument to such functions.  The asynchronous mode is strongly recommended, so as to avoid
      blocking the JavaScript main thread.  If a callback function is associated with a WebCL object
      that is subsequently released, the callback will no longer be invoked.  The signature of the
      callback function is as follows:
    </p>

<pre class="idl">
callback <dfn>WebCLCallback</dfn> = void (optional WebCLEvent event);
</pre>

    <p>
      To avoid blocking the main thread, the callback function should complete quickly and not call
      any potentially long-running functions.  Certain WebCL functions are explicitly prohibited,
      and will cause an `INVALID_OPERATION` exception if invoked from a callback.  The disallowed
      functions include `createContext`, `createCommandQueue`, and the blocking forms of `finish`,
      `waitForEvents`, `build`, and <code>enqueue{Read, Write}{Buffer, BufferRect, Image}</code>.
    </p>

<!-- ======================================================================================================= -->

    <h2>Interfaces</h2>

    <h3><a id="WEBCL">WebCL</a></h3>

    <p>
      The WebCL API is accessible through a singleton `webcl` object that resides in the global
      `window` namespace.  The `webcl` object implements the WebCL interface, providing functions
      for creating computing contexts and querying the available WebCL platforms and extensions.
    </p>

<pre class="idl">
partial interface Window {
  readonly attribute WebCL webcl;
};
</pre>

<pre class="idl">
interface <dfn>WebCL</dfn> {

  sequence&lt;WebCLPlatform&gt; getPlatforms();

  WebCLContext createContext(optional CLenum deviceType = WebCL.DEVICE_TYPE_DEFAULT);

  WebCLContext createContext(WebCLPlatform platform, optional CLenum deviceType = WebCL.DEVICE_TYPE_DEFAULT);

  WebCLContext createContext(WebCLDevice device);

  WebCLContext createContext(sequence&lt;WebCLDevice&gt; devices);

  sequence&lt;DOMString&gt;? getSupportedExtensions();

  CLboolean enableExtension(DOMString extensionName);

  void waitForEvents(sequence&lt;WebCLEvent&gt; eventWaitList,
                     optional WebCLCallback whenFinished);

  void releaseAll();


  /* Error Codes */
  const CLint SUCCESS                                   = 0;
  const CLint DEVICE_NOT_FOUND                          = -1;
  const CLint DEVICE_NOT_AVAILABLE                      = -2;
  const CLint COMPILER_NOT_AVAILABLE                    = -3;
  const CLint MEM_OBJECT_ALLOCATION_FAILURE             = -4;
  const CLint OUT_OF_RESOURCES                          = -5;
  const CLint OUT_OF_HOST_MEMORY                        = -6;
  const CLint PROFILING_INFO_NOT_AVAILABLE              = -7;
  const CLint MEM_COPY_OVERLAP                          = -8;
  const CLint IMAGE_FORMAT_MISMATCH                     = -9;
  const CLint IMAGE_FORMAT_NOT_SUPPORTED                = -10;
  const CLint BUILD_PROGRAM_FAILURE                     = -11;
  const CLint MAP_FAILURE                               = -12;
  const CLint MISALIGNED_SUB_BUFFER_OFFSET              = -13;
  const CLint EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST = -14;
  const CLint INVALID_VALUE                             = -30;
  const CLint INVALID_DEVICE_TYPE                       = -31;
  const CLint INVALID_PLATFORM                          = -32;
  const CLint INVALID_DEVICE                            = -33;
  const CLint INVALID_CONTEXT                           = -34;
  const CLint INVALID_QUEUE_PROPERTIES                  = -35;
  const CLint INVALID_COMMAND_QUEUE                     = -36;
  const CLint INVALID_HOST_PTR                          = -37;
  const CLint INVALID_MEM_OBJECT                        = -38;
  const CLint INVALID_IMAGE_FORMAT_DESCRIPTOR           = -39;
  const CLint INVALID_IMAGE_SIZE                        = -40;
  const CLint INVALID_SAMPLER                           = -41;
  const CLint INVALID_BINARY                            = -42;
  const CLint INVALID_BUILD_OPTIONS                     = -43;
  const CLint INVALID_PROGRAM                           = -44;
  const CLint INVALID_PROGRAM_EXECUTABLE                = -45;
  const CLint INVALID_KERNEL_NAME                       = -46;
  const CLint INVALID_KERNEL_DEFINITION                 = -47;
  const CLint INVALID_KERNEL                            = -48;
  const CLint INVALID_ARG_INDEX                         = -49;
  const CLint INVALID_ARG_VALUE                         = -50;
  const CLint INVALID_ARG_SIZE                          = -51;
  const CLint INVALID_KERNEL_ARGS                       = -52;
  const CLint INVALID_WORK_DIMENSION                    = -53;
  const CLint INVALID_WORK_GROUP_SIZE                   = -54;
  const CLint INVALID_WORK_ITEM_SIZE                    = -55;
  const CLint INVALID_GLOBAL_OFFSET                     = -56;
  const CLint INVALID_EVENT_WAIT_LIST                   = -57;
  const CLint INVALID_EVENT                             = -58;
  const CLint INVALID_OPERATION                         = -59;
  //const CLint INVALID_GL_OBJECT                         = -60; // moved to extension
  const CLint INVALID_BUFFER_SIZE                       = -61;
  //const CLint INVALID_MIP_LEVEL                         = -62; // moved to extension
  const CLint INVALID_GLOBAL_WORK_SIZE                  = -63;
  const CLint INVALID_PROPERTY                          = -64;

  /* cl_bool */
  const CLenum FALSE                                     = 0;
  const CLenum TRUE                                      = 1;

  /* cl_platform_info */
  const CLenum PLATFORM_PROFILE                          = 0x0900;
  const CLenum PLATFORM_VERSION                          = 0x0901;
  const CLenum PLATFORM_NAME                             = 0x0902;
  const CLenum PLATFORM_VENDOR                           = 0x0903;
  const CLenum PLATFORM_EXTENSIONS                       = 0x0904;

  /* cl_device_type - bitfield */
  const CLenum DEVICE_TYPE_DEFAULT                       = 0x1;
  const CLenum DEVICE_TYPE_CPU                           = 0x2;
  const CLenum DEVICE_TYPE_GPU                           = 0x4;
  const CLenum DEVICE_TYPE_ACCELERATOR                   = 0x8;
  const CLenum DEVICE_TYPE_ALL                           = 0xFFFFFFFF;

  /* cl_device_info */
  const CLenum DEVICE_TYPE                               = 0x1000;
  const CLenum DEVICE_VENDOR_ID                          = 0x1001;
  const CLenum DEVICE_MAX_COMPUTE_UNITS                  = 0x1002;
  const CLenum DEVICE_MAX_WORK_ITEM_DIMENSIONS           = 0x1003;
  const CLenum DEVICE_MAX_WORK_GROUP_SIZE                = 0x1004;
  const CLenum DEVICE_MAX_WORK_ITEM_SIZES                = 0x1005;
  const CLenum DEVICE_PREFERRED_VECTOR_WIDTH_CHAR        = 0x1006;
  const CLenum DEVICE_PREFERRED_VECTOR_WIDTH_SHORT       = 0x1007;
  const CLenum DEVICE_PREFERRED_VECTOR_WIDTH_INT         = 0x1008;
  const CLenum DEVICE_PREFERRED_VECTOR_WIDTH_LONG        = 0x1009;
  const CLenum DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT       = 0x100A;
  //const CLenum DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE      = 0x100B; // moved to extension
  const CLenum DEVICE_MAX_CLOCK_FREQUENCY                = 0x100C;
  const CLenum DEVICE_ADDRESS_BITS                       = 0x100D;
  const CLenum DEVICE_MAX_READ_IMAGE_ARGS                = 0x100E;
  const CLenum DEVICE_MAX_WRITE_IMAGE_ARGS               = 0x100F;
  const CLenum DEVICE_MAX_MEM_ALLOC_SIZE                 = 0x1010;
  const CLenum DEVICE_IMAGE2D_MAX_WIDTH                  = 0x1011;
  const CLenum DEVICE_IMAGE2D_MAX_HEIGHT                 = 0x1012;
  const CLenum DEVICE_IMAGE3D_MAX_WIDTH                  = 0x1013;
  const CLenum DEVICE_IMAGE3D_MAX_HEIGHT                 = 0x1014;
  const CLenum DEVICE_IMAGE3D_MAX_DEPTH                  = 0x1015;
  const CLenum DEVICE_IMAGE_SUPPORT                      = 0x1016;
  const CLenum DEVICE_MAX_PARAMETER_SIZE                 = 0x1017;
  const CLenum DEVICE_MAX_SAMPLERS                       = 0x1018;
  const CLenum DEVICE_MEM_BASE_ADDR_ALIGN                = 0x1019;
  //const CLenum DEVICE_MIN_DATA_TYPE_ALIGN_SIZE           = 0x101A; // removed; deprecated in OpenCL 1.2
  const CLenum DEVICE_SINGLE_FP_CONFIG                   = 0x101B;
  const CLenum DEVICE_GLOBAL_MEM_CACHE_TYPE              = 0x101C;
  const CLenum DEVICE_GLOBAL_MEM_CACHELINE_SIZE          = 0x101D;
  const CLenum DEVICE_GLOBAL_MEM_CACHE_SIZE              = 0x101E;
  const CLenum DEVICE_GLOBAL_MEM_SIZE                    = 0x101F;
  const CLenum DEVICE_MAX_CONSTANT_BUFFER_SIZE           = 0x1020;
  const CLenum DEVICE_MAX_CONSTANT_ARGS                  = 0x1021;
  const CLenum DEVICE_LOCAL_MEM_TYPE                     = 0x1022;
  const CLenum DEVICE_LOCAL_MEM_SIZE                     = 0x1023;
  const CLenum DEVICE_ERROR_CORRECTION_SUPPORT           = 0x1024;
  const CLenum DEVICE_PROFILING_TIMER_RESOLUTION         = 0x1025;
  const CLenum DEVICE_ENDIAN_LITTLE                      = 0x1026;
  const CLenum DEVICE_AVAILABLE                          = 0x1027;
  const CLenum DEVICE_COMPILER_AVAILABLE                 = 0x1028;
  const CLenum DEVICE_EXECUTION_CAPABILITIES             = 0x1029;
  const CLenum DEVICE_QUEUE_PROPERTIES                   = 0x102A;
  const CLenum DEVICE_NAME                               = 0x102B;
  const CLenum DEVICE_VENDOR                             = 0x102C;
  const CLenum DRIVER_VERSION                            = 0x102D;
  const CLenum DEVICE_PROFILE                            = 0x102E;
  const CLenum DEVICE_VERSION                            = 0x102F;
  const CLenum DEVICE_EXTENSIONS                         = 0x1030;
  const CLenum DEVICE_PLATFORM                           = 0x1031;
  //const CLenum DEVICE_DOUBLE_FP_CONFIG                   = 0x1032; // moved to extension
  //const CLenum DEVICE_HALF_FP_CONFIG                     = 0x1033; // moved to extension
  //const CLenum DEVICE_PREFERRED_VECTOR_WIDTH_HALF        = 0x1034; // moved to extension
  const CLenum DEVICE_HOST_UNIFIED_MEMORY                = 0x1035;
  const CLenum DEVICE_NATIVE_VECTOR_WIDTH_CHAR           = 0x1036;
  const CLenum DEVICE_NATIVE_VECTOR_WIDTH_SHORT          = 0x1037;
  const CLenum DEVICE_NATIVE_VECTOR_WIDTH_INT            = 0x1038;
  const CLenum DEVICE_NATIVE_VECTOR_WIDTH_LONG           = 0x1039;
  const CLenum DEVICE_NATIVE_VECTOR_WIDTH_FLOAT          = 0x103A;
  //const CLenum DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE         = 0x103B; // moved to extension
  //const CLenum DEVICE_NATIVE_VECTOR_WIDTH_HALF           = 0x103C; // moved to extension
  const CLenum DEVICE_OPENCL_C_VERSION                   = 0x103D;

  /* cl_device_fp_config - bitfield */
  const CLenum FP_DENORM                                 = 0x1;
  const CLenum FP_INF_NAN                                = 0x2;
  const CLenum FP_ROUND_TO_NEAREST                       = 0x4;
  const CLenum FP_ROUND_TO_ZERO                          = 0x8;
  const CLenum FP_ROUND_TO_INF                           = 0x10;
  const CLenum FP_FMA                                    = 0x20;
  const CLenum FP_SOFT_FLOAT                             = 0x40;

  /* cl_device_mem_cache_type */
  const CLenum NONE                                      = 0x0;
  const CLenum READ_ONLY_CACHE                           = 0x1;
  const CLenum READ_WRITE_CACHE                          = 0x2;

  /* cl_device_local_mem_type */
  const CLenum LOCAL                                     = 0x1;
  const CLenum GLOBAL                                    = 0x2;

  /* cl_device_exec_capabilities - bitfield */
  const CLenum EXEC_KERNEL                               = 0x1;
  //const CLenum EXEC_NATIVE_KERNEL                        = 0x2; // disallowed

  /* cl_command_queue_properties - bitfield */
  const CLenum QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE       = 0x1;
  const CLenum QUEUE_PROFILING_ENABLE                    = 0x2;

  /* cl_context_info  */
  //const CLenum CONTEXT_REFERENCE_COUNT                   = 0x1080; // disallowed
  const CLenum CONTEXT_DEVICES                           = 0x1081;
  //const CLenum CONTEXT_PROPERTIES                        = 0x1082; // disallowed; no context properties in WebCL
  const CLenum CONTEXT_NUM_DEVICES                       = 0x1083;

  /* cl_context_properties */
  //const CLenum CONTEXT_PLATFORM                          = 0x1084; // disallowed; no context properties in WebCL

  /* cl_command_queue_info */
  const CLenum QUEUE_CONTEXT                             = 0x1090;
  const CLenum QUEUE_DEVICE                              = 0x1091;
  //const CLenum QUEUE_REFERENCE_COUNT                     = 0x1092; // disallowed
  const CLenum QUEUE_PROPERTIES                          = 0x1093;

  /* cl_mem_flags - bitfield */
  const CLenum MEM_READ_WRITE                            = 0x1;
  const CLenum MEM_WRITE_ONLY                            = 0x2;
  const CLenum MEM_READ_ONLY                             = 0x4;

  /* cl_channel_order */
  const CLenum R                                         = 0x10B0;
  const CLenum A                                         = 0x10B1;
  const CLenum RG                                        = 0x10B2;
  const CLenum RA                                        = 0x10B3;
  const CLenum RGB                                       = 0x10B4;
  const CLenum RGBA                                      = 0x10B5;
  const CLenum BGRA                                      = 0x10B6;
  const CLenum ARGB                                      = 0x10B7;
  const CLenum INTENSITY                                 = 0x10B8;
  const CLenum LUMINANCE                                 = 0x10B9;
  const CLenum Rx                                        = 0x10BA;
  const CLenum RGx                                       = 0x10BB;
  const CLenum RGBx                                      = 0x10BC;

  /* cl_channel_type */
  const CLenum SNORM_INT8                                = 0x10D0;
  const CLenum SNORM_INT16                               = 0x10D1;
  const CLenum UNORM_INT8                                = 0x10D2;
  const CLenum UNORM_INT16                               = 0x10D3;
  const CLenum UNORM_SHORT_565                           = 0x10D4;
  const CLenum UNORM_SHORT_555                           = 0x10D5;
  const CLenum UNORM_INT_101010                          = 0x10D6;
  const CLenum SIGNED_INT8                               = 0x10D7;
  const CLenum SIGNED_INT16                              = 0x10D8;
  const CLenum SIGNED_INT32                              = 0x10D9;
  const CLenum UNSIGNED_INT8                             = 0x10DA;
  const CLenum UNSIGNED_INT16                            = 0x10DB;
  const CLenum UNSIGNED_INT32                            = 0x10DC;
  const CLenum HALF_FLOAT                                = 0x10DD;
  const CLenum FLOAT                                     = 0x10DE;

  /* cl_mem_object_type */
  const CLenum MEM_OBJECT_BUFFER                         = 0x10F0;
  const CLenum MEM_OBJECT_IMAGE2D                        = 0x10F1;
  //const CLenum MEM_OBJECT_IMAGE3D                        = 0x10F2; // moved to extension (TBD)

  /* cl_mem_info */
  const CLenum MEM_TYPE                                  = 0x1100;
  const CLenum MEM_FLAGS                                 = 0x1101;
  const CLenum MEM_SIZE                                  = 0x1102;
  //const CLenum MEM_HOST_PTR                              = 0x1103; // disallowed
  //const CLenum MEM_MAP_COUNT                             = 0x1104; // disallowed
  //const CLenum MEM_REFERENCE_COUNT                       = 0x1105; // disallowed
  const CLenum MEM_CONTEXT                               = 0x1106;
  const CLenum MEM_ASSOCIATED_MEMOBJECT                  = 0x1107;
  const CLenum MEM_OFFSET                                = 0x1108;

  /* cl_image_info */
  const CLenum IMAGE_FORMAT                              = 0x1110;
  const CLenum IMAGE_ELEMENT_SIZE                        = 0x1111;
  const CLenum IMAGE_ROW_PITCH                           = 0x1112;
  const CLenum IMAGE_WIDTH                               = 0x1114;
  const CLenum IMAGE_HEIGHT                              = 0x1115;

  /* cl_addressing_mode */
  //const CLenum ADDRESS_NONE                              = 0x1130; // disallowed
  const CLenum ADDRESS_CLAMP_TO_EDGE                     = 0x1131;
  const CLenum ADDRESS_CLAMP                             = 0x1132;
  const CLenum ADDRESS_REPEAT                            = 0x1133;
  const CLenum ADDRESS_MIRRORED_REPEAT                   = 0x1134;

  /* cl_filter_mode */
  const CLenum FILTER_NEAREST                            = 0x1140;
  const CLenum FILTER_LINEAR                             = 0x1141;

  /* cl_sampler_info */
  //const CLenum SAMPLER_REFERENCE_COUNT                   = 0x1150; // disallowed
  const CLenum SAMPLER_CONTEXT                           = 0x1151;
  const CLenum SAMPLER_NORMALIZED_COORDS                 = 0x1152;
  const CLenum SAMPLER_ADDRESSING_MODE                   = 0x1153;
  const CLenum SAMPLER_FILTER_MODE                       = 0x1154;

  /* cl_map_flags - bitfield */
  //const CLenum MAP_READ                                  = 0x1; // disallowed
  //const CLenum MAP_WRITE                                 = 0x2; // disallowed

  /* cl_program_info */
  //const CLenum PROGRAM_REFERENCE_COUNT                   = 0x1160; // disallowed
  const CLenum PROGRAM_CONTEXT                           = 0x1161;
  const CLenum PROGRAM_NUM_DEVICES                       = 0x1162;
  const CLenum PROGRAM_DEVICES                           = 0x1163;
  const CLenum PROGRAM_SOURCE                            = 0x1164;
  //const CLenum PROGRAM_BINARY_SIZES                      = 0x1165; // disallowed
  //const CLenum PROGRAM_BINARIES                          = 0x1166; // disallowed

  /* cl_program_build_info */
  const CLenum PROGRAM_BUILD_STATUS                      = 0x1181;
  const CLenum PROGRAM_BUILD_OPTIONS                     = 0x1182;
  const CLenum PROGRAM_BUILD_LOG                         = 0x1183;

  /* cl_build_status */
  const CLint BUILD_SUCCESS                             = 0;
  const CLint BUILD_NONE                                = -1;
  const CLint BUILD_ERROR                               = -2;
  const CLint BUILD_IN_PROGRESS                         = -3;

  /* cl_kernel_info */
  const CLenum KERNEL_FUNCTION_NAME                      = 0x1190;
  const CLenum KERNEL_NUM_ARGS                           = 0x1191;
  //const CLenum KERNEL_REFERENCE_COUNT                    = 0x1192; // disallowed
  const CLenum KERNEL_CONTEXT                            = 0x1193;
  const CLenum KERNEL_PROGRAM                            = 0x1194;

  /* cl_kernel_work_group_info */
  const CLenum KERNEL_WORK_GROUP_SIZE                    = 0x11B0;
  const CLenum KERNEL_COMPILE_WORK_GROUP_SIZE            = 0x11B1;
  const CLenum KERNEL_LOCAL_MEM_SIZE                     = 0x11B2;
  const CLenum KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = 0x11B3;
  const CLenum KERNEL_PRIVATE_MEM_SIZE                   = 0x11B4;

  /* cl_event_info  */
  const CLenum EVENT_COMMAND_QUEUE                       = 0x11D0;
  const CLenum EVENT_COMMAND_TYPE                        = 0x11D1;
  //const CLenum EVENT_REFERENCE_COUNT                     = 0x11D2; // disallowed
  const CLenum EVENT_COMMAND_EXECUTION_STATUS            = 0x11D3;
  const CLenum EVENT_CONTEXT                             = 0x11D4;

  /* cl_command_type */
  const CLenum COMMAND_NDRANGE_KERNEL                    = 0x11F0;
  const CLenum COMMAND_TASK                              = 0x11F1;
  //const CLenum COMMAND_NATIVE_KERNEL                     = 0x11F2; // disallowed
  const CLenum COMMAND_READ_BUFFER                       = 0x11F3;
  const CLenum COMMAND_WRITE_BUFFER                      = 0x11F4;
  const CLenum COMMAND_COPY_BUFFER                       = 0x11F5;
  const CLenum COMMAND_READ_IMAGE                        = 0x11F6;
  const CLenum COMMAND_WRITE_IMAGE                       = 0x11F7;
  const CLenum COMMAND_COPY_IMAGE                        = 0x11F8;
  const CLenum COMMAND_COPY_IMAGE_TO_BUFFER              = 0x11F9;
  const CLenum COMMAND_COPY_BUFFER_TO_IMAGE              = 0x11FA;
  //const CLenum COMMAND_MAP_BUFFER                        = 0x11FB; // disallowed
  //const CLenum COMMAND_MAP_IMAGE                         = 0x11FC; // disallowed
  //const CLenum COMMAND_UNMAP_MEM_OBJECT                  = 0x11FD; // disallowed
  const CLenum COMMAND_MARKER                            = 0x11FE;
  //const CLenum COMMAND_ACQUIRE_GL_OBJECTS                = 0x11FF; // moved to extension
  //const CLenum COMMAND_RELEASE_GL_OBJECTS                = 0x1200; // moved to extension
  const CLenum COMMAND_READ_BUFFER_RECT                  = 0x1201;
  const CLenum COMMAND_WRITE_BUFFER_RECT                 = 0x1202;
  const CLenum COMMAND_COPY_BUFFER_RECT                  = 0x1203;
  const CLenum COMMAND_USER                              = 0x1204;

  /* command execution status */
  const CLenum COMPLETE                                  = 0x0;
  const CLenum RUNNING                                   = 0x1;
  const CLenum SUBMITTED                                 = 0x2;
  const CLenum QUEUED                                    = 0x3;

  /* cl_profiling_info  */
  const CLenum PROFILING_COMMAND_QUEUED                  = 0x1280;
  const CLenum PROFILING_COMMAND_SUBMIT                  = 0x1281;
  const CLenum PROFILING_COMMAND_START                   = 0x1282;
  const CLenum PROFILING_COMMAND_END                     = 0x1283;
};
</pre>

    <dl class="methods">

      <dt class="idl-code">sequence&lt;WebCLPlatform&gt; getPlatforms()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=32">OpenCL 1.1 §4.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetPlatformIDs.html">clGetPlatformIDs</a>)</span>
      </dt>
      <dd>
        Retrieves all WebCL platforms that are available in this system.
      </dd>

      <dt class="idl-code">WebCLContext createContext(optional CLenum deviceType = WebCL.DEVICE_TYPE_DEFAULT)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=45">OpenCL 1.1 §4.3</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateContextFromType.html">clCreateContextFromType</a>)</span>
      </dt>
      <dd>
        Returns a newly created WebCL context for the given type of device, if available.  If there
        are multiple devices of the given type, the implementation may select any one of them, a
        subset of them, or all of them.  The available values for `deviceType` are listed in the
        table below.

        <table class="enumtable">
          <tr><th>deviceType</th><th>Description</th></tr>
          <tr><td>DEVICE_TYPE_CPU</td><td>A single-core or multi-core CPU, typically the host processor.</td></tr>
          <tr><td>DEVICE_TYPE_GPU</td><td>A graphics processing unit, typically also used by WebGL.</td></tr>
          <tr><td>DEVICE_TYPE_ACCELERATOR</td><td>A dedicated OpenCL accelerator.</td></tr>
          <tr><td>DEVICE_TYPE_DEFAULT</td><td>The default device(s) on the system.</td></tr>
        </table>
      </dd>

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_OPERATION` -- if this function is called from a WebCLCallback</li>
	        <li>`INVALID_DEVICE_TYPE` -- if `deviceType` is not a valid `DEVICE_TYPE`</li>
	        <li>`DEVICE_NOT_FOUND` -- if no devices that match `deviceType` were found on any platform</li>
	        <li>`DEVICE_NOT_AVAILABLE` -- if no devices that match `deviceType` are currently available on any platform</li>
        </ul>
      </dd>

      <dt class="idl-code">WebCLContext createContext(WebCLPlatform platform, optional CLenum deviceType = WebCL.DEVICE_TYPE_DEFAULT)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=45">OpenCL 1.1 §4.3</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateContextFromType.html">clCreateContextFromType</a>)</span>
      </dt>
      <dd>
        Returns a newly created WebCL context for the given type of device, if available on the
        given platform.  If there are multiple devices of the given type, the implementation may
        select any one of them, a subset of them, or all of them.  The available values for
        `deviceType` are listed in the table below.

        <table class="enumtable">
          <tr><th>deviceType</th><th>Description</th></tr>
          <tr><td>DEVICE_TYPE_CPU</td><td>A single-core or multi-core CPU, typically the host processor.</td></tr>
          <tr><td>DEVICE_TYPE_GPU</td><td>A graphics processing unit, typically also used by WebGL.</td></tr>
          <tr><td>DEVICE_TYPE_ACCELERATOR</td><td>A dedicated OpenCL accelerator.</td></tr>
          <tr><td>DEVICE_TYPE_DEFAULT</td><td>The default device(s) on the given platform.</td></tr>
          <tr><td>DEVICE_TYPE_ALL</td><td>All devices available on the given platform.</td></tr>
        </table>

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_OPERATION` -- if this function is called from a WebCLCallback</li>
	        <li>`INVALID_PLATFORM` -- if `platform` is not a valid WebCLPlatform object</li>
	        <li>`INVALID_DEVICE_TYPE` -- if `deviceType` is not a valid `DEVICE_TYPE`</li>
	        <li>`DEVICE_NOT_FOUND` -- if no devices that match `deviceType` were found on the given platform</li>
	        <li>`DEVICE_NOT_AVAILABLE` -- if no devices that match `deviceType` are currently available on the given platform</li>
        </ul>
      </dd>

      <dt class="idl-code">WebCLContext createContext(WebCLDevice device)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=45">OpenCL 1.1 §4.3</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateContext.html">clCreateContext</a>)</span>
      </dt>
      <dd>
        Returns a newly created WebCL context for the given device.

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_OPERATION` -- if this function is called from a WebCLCallback</li>
	        <li>`INVALID_DEVICE` -- if `device` is not a valid WebCLDevice object</li>
	        <li>`DEVICE_NOT_AVAILABLE` -- if the given device is currently not available</li>
        </ul>
      </dd>

      <dt class="idl-code">WebCLContext createContext(sequence&lt;WebCLDevice&gt; devices)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=45">OpenCL 1.1 §4.3</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateContext.html">clCreateContext</a>)</span>
      </dt>
      <dd>
        Returns a newly created WebCL context spanning the given list of devices.

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_OPERATION` -- if this function is called from a WebCLCallback</li>
	        <li>`INVALID_VALUE` -- if <code>devices.length === 0</code></li>
	        <li>`INVALID_DEVICE` -- if any element in `devices` is not a valid WebCLDevice</li>
	        <li>`INVALID_DEVICE` -- if any of the given devices are on different platforms</li>
	        <li>`DEVICE_NOT_AVAILABLE` -- if any of the given devices are currently not available</li>
        </ul>
      </dd>

      <dt class="idl-code">sequence&lt;DOMString&gt;? getSupportedExtensions()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-9">OpenCL 1.1 §9</a>)</span>
      </dt>
      <dd>
        Returns an array of extension names that are supported by all
        WebCLPlatforms and WebCLDevices in this implementation.  Any
        string in this list, when passed to `enableExtension`, must
        enable the corresponding extension.
      </dd>

      <dt class="idl-code">CLboolean enableExtension(DOMString extensionName)</dt>
      <dd>
        Enables the given extension on all WebCLPlatforms and WebCLDevices.  Returns `true` if the
        extension is successfully enabled, or `false` if not.  The available extension names can be
        queried by `getSupportedExtensions`.  Note that enabling an extension does not take effect
        retroactively, i.e., contexts that were created before enabling the extension will continue
        to not have the extended capabilities.
      </dd>

      <dt class="idl-code">void waitForEvents(sequence&lt;WebCLEvent&gt; eventWaitList, optional WebCLCallback whenFinished)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=141">OpenCL 1.1 §5.9</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clWaitForEvents.html">clWaitForEvents</a>)</span>
      </dt>
      <dd>
        Invokes the given callback when all events in `eventWaitList` have completed.  If a callback
        is not provided, the JavaScript main thread will be blocked until the events have completed.
        Applications are strongly advised to provide a callback; the blocking mode mainly exists to
        ease the porting of existing OpenCL code.

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_OPERATION` -- if the blocking form of this function is called from a WebCLCallback</li>
	        <li>`INVALID_VALUE` -- if `eventWaitList` is empty</li>
	        <li>`INVALID_CONTEXT` -- if events specified in `eventWaitList` do not belong to the same
	          context</li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if any event in `eventWaitList` is invalid</li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if a callback is not provided, and any event in
            `eventWaitList` is a WebCLUserEvent or a newly created (non-activated) WebCLEvent</li>
          <li>`EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST` --
            if the execution status of any of the events in
            `eventWaitList` is a negative integer value</li>
        </ul>
      </dd>

      <dt class="idl-code">void releaseAll()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=48">OpenCL 1.1 §4.3</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clReleaseContext.html">clReleaseContext</a>)</span>
      </dt>
      <dd>
        Releases the resources held up by all WebCLContext instances,
        as well as their descendant objects, if any.
      </dd>

    </dl>

<pre class="example">
// Valid examples of createContext. All of these will create a valid
// context, assuming that a suitable device is available.

ctx = webcl.createContext();
ctx = webcl.createContext(WebCL.DEVICE_TYPE_CPU);
ctx = webcl.createContext(aPlatform);
ctx = webcl.createContext(aPlatform, WebCL.DEVICE_TYPE_GPU);
ctx = webcl.createContext(aPlatform, WebCL.DEVICE_TYPE_ALL);
ctx = webcl.createContext(aDevice);
ctx = webcl.createContext([aDevice, anotherDeviceOnTheSamePlatform]);

// Invalid examples of createContext. These will throw an exception.

ctx = webcl.createContext(0x1234);
ctx = webcl.createContext(WebCL.DEVICE_TYPE_ALL);
ctx = webcl.createContext({});
ctx = webcl.createContext([]);
ctx = webcl.createContext(aPlatform, 0x1234);
ctx = webcl.createContext([aValidDevice, null]);
ctx = webcl.createContext([aDeviceOnPlatformA, aDeviceOnPlatformB]);
</pre>

<!-- ======================================================================================================= -->

    <h3><a id="WEBCLPLATFORM">WebCLPlatform</a></h3>

    <p>
    </p>

<pre class="idl">
interface <dfn>WebCLPlatform</dfn> {
  any getInfo(CLenum name);
  sequence&lt;WebCLDevice&gt; getDevices(optional CLenum deviceType = WebCL.DEVICE_TYPE_ALL);
  sequence&lt;DOMString&gt;? getSupportedExtensions();
  CLboolean enableExtension(DOMString extensionName);
};
</pre>

    <dl class="methods">

      <dt class="idl-code">sequence&lt;WebCLDevice&gt; getDevices(optional CLenum deviceType = WebCL.DEVICE_TYPE_ALL)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=34">OpenCL 1.1 §4.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetDeviceIDs.html">clGetDeviceIDs</a>)</span>
      </dt>
      <dd>
        <p>
          Retrieves the WebCLDevices that are available on this
          WebCLPlatform and match the given device type. The valid
          device types are listed in the table below.  Omitting the
          device type is equivalent to specifying `DEVICE_TYPE_ALL`.
        </p>

        <table class="enumtable">
          <tr><th>deviceType</th><th>description</th></tr>
          <tr><td>DEVICE_TYPE_CPU</td><td>A single-core or multi-core CPU, typically the host processor.</td></tr>
          <tr><td>DEVICE_TYPE_GPU</td><td>A graphics processing unit, typically also used by WebGL.</td></tr>
          <tr><td>DEVICE_TYPE_ACCELERATOR</td><td>A dedicated OpenCL accelerator.</td></tr>
          <tr><td>DEVICE_TYPE_DEFAULT</td><td>The default device on this platform.</td></tr>
          <tr><td>DEVICE_TYPE_ALL</td><td>All devices available on this platform.</td></tr>
        </table>

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_DEVICE_TYPE` -- if `deviceType` is given, but is not one of the valid enumerated values listed in the table above</li>
          <li>`DEVICE_NOT_FOUND` -- if there is no WebCLDevice available that matches the given `deviceType`</li>
        </ul>
      </dd>

      <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=32">OpenCL 1.1 §4.1</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetPlatformInfo.html">clGetPlatformInfo</a>)</span>
      </dt>
      <dd>
        <p>
          Retrieves information about this WebCLPlatform.  The available query parameters are listed
          in the table below.  Note that depending on the privacy policy of the implementation, some
          of the return values may be empty or otherwise not reflective of the underlying OpenCL
          platform.  Implementations that choose to mask the underlying values are recommended to
          make them available for privileged applications (such as browser extensions and
          development tools) via the <a href="#WEBCL_system_info">System Info</a> extension.
        </p>

        <table class="enumtable" id="getPlatformInfoEnums">
          <tr><th>name</th><th>return type</th><th>expected return value</th>
          <tr><td>PLATFORM_PROFILE</td><td>DOMString</td><td>"WEBCL_PROFILE" + optional vendor string</td></tr>
          <tr><td>PLATFORM_VERSION</td><td>DOMString</td><td>"WebCL 1.0" + optional vendor string</td></tr>
          <tr><td>PLATFORM_NAME</td><td>DOMString</td><td>Vendor specific</td></tr>
          <tr><td>PLATFORM_VENDOR</td><td>DOMString</td><td>Vendor specific</td></tr>
          <tr><td>PLATFORM_EXTENSIONS</td><td>DOMString</td><td>Vendor specific</td></tr>
        </table>

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if `name` is not one of the valid enumerated values</li>
        </ul>
      </dd>

      <dt class="idl-code">sequence&lt;DOMString&gt;? getSupportedExtensions()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=269">OpenCL 1.1 §9</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetPlatformInfo.html">clGetPlatformInfo</a>)</span>
      </dt>
      <dd>
        Returns an array of extension names that are supported by all
        WebCLDevices on this WebCLPlatform.  Any string in this list,
        when passed to `enableExtension` on this platform, or any device
        on this platform, must enable the corresponding extension.
      </dd>

      <dt class="idl-code">CLboolean enableExtension(DOMString extensionName)</dt>
      <dd>
        Enables the given WebCL extension on this WebCLPlatform.  Returns `true` if the extension is
        successfully enabled, or `false` if not.  The available extension names can be queried by
        `getSupportedExtensions`.  Note that enabling an extension does not take effect
        retroactively, i.e., contexts that were created before enabling the extension will continue
        to not have the extended capabilities.
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h3><a id="WEBCLDEVICE">WebCLDevice</a></h3>

    <p>
    </p>

<pre class="idl">
interface <dfn>WebCLDevice</dfn> {
  any getInfo(CLenum name);
  sequence&lt;DOMString&gt;? getSupportedExtensions();
  CLboolean enableExtension(DOMString extensionName);
};
</pre>

    <dl class="methods">

      <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=36">OpenCL 1.1 §4.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetDeviceInfo.html">clGetDeviceInfo</a>)</span>
      </dt>
      <dd>
      <dd>
        <p>
          Retrieves information about this WebCLDevice.  The available query parameters are listed
          in the table below.  Note that depending on the privacy policy of the implementation, some
          of the return values may be empty or otherwise not reflective of the underlying OpenCL
          device.  Implementations that choose to mask the underlying values are recommended to make
          them available for privileged applications (such as browser extensions and development
          tools) via the <a href="#WEBCL_system_info">System Info</a> extension.
        </p>

        <table class="enumtable" id="getDeviceInfoEnums">
          <tr><th>name</th><th>return type</th><th>expected return value</th>
          <tr><td>DEVICE_PROFILE</td><td>DOMString</td><td>"WEBCL_PROFILE" + optional vendor string</td></tr>
          <tr><td>DEVICE_VERSION</td><td>DOMString</td><td>"WebCL 1.0" + optional vendor string</td></tr>
          <tr><td>DEVICE_OPENCL_C_VERSION</td><td>DOMString</td><td>"WebCL C 1.0" + optional vendor string</td></tr>
          <tr><td>DEVICE_NAME</td><td>DOMString</td><td>Vendor specific</td></tr>
          <tr><td>DEVICE_VENDOR</td><td>DOMString</td><td>Vendor specific</td></tr>
          <tr><td>DEVICE_VENDOR_ID</td><td>CLuint</td><td>Vendor specific</td></tr>
          <tr><td>DRIVER_VERSION</td><td>DOMString</td><td>Vendor specific</td></tr>
          <tr><td>DEVICE_EXTENSIONS</td><td>DOMString</td><td>Vendor specific</td></tr>
          <tr><td>DEVICE_AVAILABLE</td><td>CLboolean</td><td>true</td></tr>
          <tr><td>DEVICE_COMPILER_AVAILABLE</td><td>CLboolean</td><td>true</td></tr>
          <tr><td>DEVICE_TYPE</td><td>CLenum</td><td>
              One or more of {
              DEVICE_TYPE_CPU,
              DEVIDE_TYPE_GPU,
              DEVICE_TYPE_ACCELERATOR }</td></tr>
          <tr><td>DEVICE_MAX_COMPUTE_UNITS</td><td>CLuint</td><td>&gt;= 1</td></tr>
          <tr><td>DEVICE_MAX_WORK_ITEM_DIMENSIONS</td><td>CLuint</td><td>&gt;= 3</td></tr>
          <tr><td>DEVICE_MAX_WORK_ITEM_SIZES</td><td>CLuint</td><td>&gt;= (1, 1, 1)</td></tr>
          <tr><td>DEVICE_MAX_WORK_GROUP_SIZE</td><td>CLuint</td><td>&gt;= 1</td></tr>
          <tr><td>DEVICE_PREFERRED_VECTOR_WIDTH_{CHAR, SHORT, INT, LONG, FLOAT}</td><td>CLuint</td><td>&gt;= 1</td></tr>
          <tr><td>DEVICE_NATIVE_VECTOR_WIDTH_{CHAR, SHORT, INT, LONG, FLOAT}</td><td>CLuint</td><td>&gt;= 1</td></tr>
          <tr><td>DEVICE_MAX_CLOCK_FREQUENCY</td><td>CLuint</td><td>&gt;= 0</td></tr>
          <tr><td>DEVICE_ADDRESS_BITS</td><td>CLuint</td><td>32 or 64</td></tr>
          <tr><td>DEVICE_MAX_MEM_ALLOC_SIZE</td><td>CLulong</td><td>&gt;= max(DEVICE_GLOBAL_MEM_SIZE/4, 1024*1024)</td></tr>
          <tr><td>DEVICE_IMAGE_SUPPORT</td><td>CLboolean</td><td>true</td></tr>
          <tr><td>DEVICE_MAX_READ_IMAGE_ARGS</td><td>CLuint</td><td>&gt;= 8</td></tr>
          <tr><td>DEVICE_MAX_WRITE_IMAGE_ARGS</td><td>CLuint</td><td>&gt;= 1</td></tr>
          <tr><td>DEVICE_IMAGE2D_MAX_WIDTH</td><td>CLuint</td><td>&gt;= 2048</td></tr>
          <tr><td>DEVICE_IMAGE2D_MAX_HEIGHT</td><td>CLuint</td><td>&gt;= 2048</td></tr>
          <tr><td>DEVICE_IMAGE3D_MAX_WIDTH</td><td>CLuint</td><td>&gt;= 0</td></tr>
          <tr><td>DEVICE_IMAGE3D_MAX_HEIGHT</td><td>CLuint</td><td>&gt;= 0</td></tr>
          <tr><td>DEVICE_IMAGE3D_MAX_DEPTH</td><td>CLuint</td><td>&gt;= 0</td></tr>
          <tr><td>DEVICE_MAX_SAMPLERS</td><td>CLuint</td><td>&gt;= 8</td></tr>
          <tr><td>DEVICE_MAX_PARAMETER_SIZE</td><td>CLuint</td><td>&gt;= 256 bytes</td></tr>
          <tr><td>DEVICE_MEM_BASE_ADDR_ALIGN</td><td>CLuint</td><td>&gt;= numBits(float16) = 16*32 = 512</td></tr>
          <tr><td>DEVICE_SINGLE_FP_CONFIG</td><td>CLenum</td><td> A
              combination of one or more of { FP_ROUND_TO_NEAREST,
              FP_ROUND_TO_ZERO } and zero or more of { FP_DENORM,
              FP_INF_NAN, FP_ROUND_TO_INF, FP_FMA, FP_SOFT_FLOAT }.
          </td></tr>
          <tr><td>DEVICE_GLOBAL_MEM_CACHE_TYPE</td><td>CLenum</td><td>Exactly one of { NONE, READ_ONLY_CACHE, READ_WRITE_CACHE }</td></tr>
          <tr><td>DEVICE_GLOBAL_MEM_CACHELINE_SIZE</td><td>CLuint</td><td>&gt;= 0 bytes</td></tr>
          <tr><td>DEVICE_GLOBAL_MEM_CACHE_SIZE</td><td>CLulong</td><td>&gt;= 0 bytes</td></tr>
          <tr><td>DEVICE_GLOBAL_MEM_SIZE</td><td>CLulong</td><td>&gt;= 1024*1024 bytes</td></tr>
          <tr><td>DEVICE_MAX_CONSTANT_BUFFER_SIZE</td><td>CLulong</td><td>&gt;= 1024 bytes</td></tr>
          <tr><td>DEVICE_MAX_CONSTANT_ARGS</td><td>CLuint</td><td>&gt;= 4</td></tr>
          <tr><td>DEVICE_LOCAL_MEM_TYPE</td><td>CLenum</td><td>Exactly one of { LOCAL, GLOBAL }</td></tr>
          <tr><td>DEVICE_LOCAL_MEM_SIZE</td><td>CLulong</td><td>&gt;= 1024 bytes</td></tr>
          <tr><td>DEVICE_ERROR_CORRECTION_SUPPORT</td><td>CLboolean</td><td>true/false</td></tr>
          <tr><td>DEVICE_HOST_UNIFIED_MEMORY</td><td>CLboolean</td><td>true/false</td></tr>
          <tr><td>DEVICE_PROFILING_TIMER_RESOLUTION</td><td>CLuint</td><td>&gt;= 0</td></tr>
          <tr><td>DEVICE_ENDIAN_LITTLE</td><td>CLboolean</td><td>true/false</td></tr>
          <tr><td>DEVICE_EXECUTION_CAPABILITIES</td><td>CLenum</td><td>EXEC_KERNEL</td></tr>
          <tr><td>DEVICE_QUEUE_PROPERTIES</td><td>CLenum</td><td>Zero
              or more of { QUEUE_PROFILING_ENABLE,
              QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE }</td></tr>
          <tr><td>DEVICE_PLATFORM</td><td>WebCLPlatform</td><td>Object</td></tr>
        </table>

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if `name` is not one of the valid enumerated values</li>
        </ul>
      </dd>

      <dt class="idl-code">sequence&lt;DOMString&gt;? getSupportedExtensions()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=269">OpenCL 1.1 §9</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetDeviceInfo.html">clGetDeviceInfo</a>)</span>
      </dt>
      <dd>
        Returns an array of extension names that are supported by this
        WebCLDevice. Any string in this list, when passed to
        `enableExtension`, must enable the corresponding extension.
      </dd>

      <dt class="idl-code">CLboolean enableExtension(DOMString extensionName)</dt>
      <dd>
        Enables the given WebCL extension on this WebCLDevice.  Returns `true` if the extension is
        successfully enabled, or `false` if not.  The available extension names can be queried by
        `getSupportedExtensions`.  Note that enabling an extension does not take effect
        retroactively, i.e., contexts that were created before enabling the extension will continue
        to not have the extended capabilities.
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h3><a id="WEBCLCONTEXT">WebCLContext</a></h3>

    <p>
    </p>

    <pre class="idl">
interface <dfn>WebCLContext</dfn> {

  WebCLBuffer createBuffer(CLenum memFlags, CLuint sizeInBytes, optional ArrayBufferView hostPtr);

  WebCLCommandQueue createCommandQueue(optional WebCLDevice? device = null, optional CLenum properties = 0);

  WebCLImage createImage(CLenum memFlags,
                         WebCLImageDescriptor descriptor,
                         optional ArrayBufferView hostPtr);

  WebCLProgram createProgram(DOMString source);

  WebCLSampler createSampler(CLboolean normalizedCoords,
                             CLenum addressingMode,
                             CLenum filterMode);

  WebCLUserEvent createUserEvent();

  any getInfo(CLenum name);

  sequence&lt;WebCLImageDescriptor&gt;? getSupportedImageFormats(optional CLenum memFlags = WebCL.MEM_READ_WRITE);

  void release();

  void releaseAll();
};
</pre>

    <dl class="methods">
      <dt class="idl-code">WebCLBuffer createBuffer(CLenum memFlags, CLuint sizeInBytes, optional ArrayBufferView hostPtr)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=56">OpenCL 1.1 §5.2.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateBuffer.html">clCreateBuffer</a>)</span>
      </dt>
      <dd>
        Creates a new WebCLBuffer with a capacity of `sizeInBytes`,
        and optionally fills it with data from the given ArrayBufferView.

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if `memFlags` is not `MEM_READ_WRITE`, `MEM_WRITE_ONLY`, or `MEM_READ_ONLY`</li>
          <li>`INVALID_BUFFER_SIZE` -- if <code>sizeInBytes == 0 || sizeInBytes &gt; DEVICE_MAX_MEM_ALLOC_SIZE</code></li>
          <li>`INVALID_HOST_PTR` -- if <code>hostPtr.byteLength &lt; sizeInBytes</code></li>
        </ul>
      </dd>
      <dt class="idl-code">WebCLCommandQueue createCommandQueue(optional WebCLDevice? device = null, optional CLenum properties = 0)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=51">OpenCL 1.1 §5.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateCommandQueue.html">clCreateCommandQueue</a>)</span>
      </dt>
      <dd>
        Creates a new command queue for the given device.  If `device`
        is `null`, the WebCL implementation will select any
        WebCLDevice that matches the given `properties` and is covered
        by this WebCLContext.  If `properties` is omitted, the command
        queue is created with out-of-order execution disabled and
        profiling disabled.

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_OPERATION` -- if this function is called from a WebCLCallback</li>
          <li>`INVALID_DEVICE` -- if `device` is invalid or not associated with this context</li>
          <li>`INVALID_VALUE` -- if values specified in `properties` are not valid</li>
          <li>`INVALID_QUEUE_PROPERTIES` -- if values specified in `properties` are valid but not supported by the device</li>
        </ul>
      </dd>
      <dt class="idl-code">WebCLImage createImage(CLenum memFlags, WebCLImageDescriptor descriptor, optional ArrayBufferView hostPtr)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=76">OpenCL 1.1 §5.3.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateImage2D.html">clCreateImage2D</a>)</span>
      </dt>
      <dd>
        Creates a new WebCLImage with the width and height specified
        in `descriptor`, and optionally fills it with data from the
        given ArrayBufferView.

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if `memFlags` is not `MEM_READ_WRITE`, `MEM_WRITE_ONLY`, or `MEM_READ_ONLY`</li>
          <li>`INVALID_IMAGE_SIZE` -- if <code>descriptor.width == 0 || descriptor.width &gt; DEVICE_IMAGE2D_MAX_WIDTH</code>
          <li>`INVALID_IMAGE_SIZE` -- if <code>descriptor.height == 0 || descriptor.height &gt; DEVICE_IMAGE2D_MAX_HEIGHT</code>
          <li>`INVALID_IMAGE_SIZE` -- if <code>hostPtr === null && descriptor.rowPitch !== 0</code>
          <li>`INVALID_IMAGE_SIZE` -- if <code>hostPtr !== null && descriptor.rowPitch &gt; 0 && descriptor.rowPitch &lt; descriptor.width * bytesPerPixel</code>
          <li>`INVALID_HOST_PTR` -- if <code>hostPtr.byteLength &lt; descriptor.rowPitch * descriptor.height</code></li>
          <li>`INVALID_IMAGE_FORMAT_DESCRIPTOR` -- if `descriptor.channelOrder` or `descriptor.channelType` is not valid</li>
          <li>`IMAGE_FORMAT_NOT_SUPPORTED` -- if the given combination `channelOrder`, `channelType` and `memFlags` is not supported by this WebCLContext</li>
        </ul>
      </dd>
      <dt class="idl-code">WebCLProgram createProgram(DOMString source)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=110">OpenCL 1.1 §5.6.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateProgramWithSource.html">clCreateProgramWithSource</a>)</span>
      </dt>
      <dd>
        Creates a WebCLProgram from a UTF-8 string.

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if `source` is empty</li>
        </ul>
      </dd>

      <dt class="idl-code">WebCLSampler createSampler(CLboolean normalizedCoords, CLenum addressingMode, CLenum filterMode)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=106">OpenCL 1.1 §5.5.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateSampler.html">clCreateSampler</a>)</span>
      </dt>
      <dd>
        Creates a new WebCLSampler with the given coordinate mode,
        addressing mode, and filtering mode.  The `ADDRESS_NONE` mode
        is not available, due to its lack of bounds checking.

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if `addressingMode` is not
            `ADDRESS_CLAMP`, `ADDRESS_CLAMP_TO_EDGE`,
            `ADDRESS_REPEAT`, or `ADDRESS_MIRRORED_REPEAT`</li>
          <li>`INVALID_VALUE` -- if `filterMode` is not
            `FILTER_NEAREST` or `FILTER_LINEAR`</li>
          <li>`INVALID_VALUE` -- if `normalizedCoords` is `false` and
            `addressingMode` is `ADDRESS_REPEAT` or
            `ADDRESS_MIRRORED_REPEAT`</li>
        </ul>
      </dd>

      <dt class="idl-code">WebCLUserEvent createUserEvent()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=142">OpenCL 1.1 §5.9</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateUserEvent.html">clCreateUserEvent</a>)</span>
      </dt>
      <dd>
      </dd>

      <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=49">OpenCL 1.1 §4.3</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetContextInfo.html">clGetContextInfo</a>)</span>
      </dt>
      <dd>
        <p>
          Returns the value for the passed name. The type returned is the natural type for the
          requested name, as given in the table below.
        </p>

        <table class="enumtable">
          <tr><th>name</th><th>return type</th><th>description</th></tr>
          <tr><td>CONTEXT_NUM_DEVICES</td><td>CLuint</td><td>the number of devices in this context</td></tr>
          <tr><td>CONTEXT_DEVICES</td><td>sequence&lt;WebCLDevice&gt;</td><td>the devices in this context</td></tr>
        </table>

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if `name` is not one of the valid enumerated values listed in the table above</li>
        </ul>
      </dd>

      <dt class="idl-code">sequence&lt;WebCLImageDescriptor&gt;? getSupportedImageFormats(optional CLenum memFlags = WebCL.MEM_READ_WRITE)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=82">OpenCL 1.1 §5.3.2</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetSupportedImageFormats.html">clGetSupportedImageFormats</a>)</span>
      </dt>
      <dd>
        <p>
          Returns a list of image formats that are supported by this
          WebCLContext with the given `memFlags`. For example, passing
          in `MEM_READ_WRITE` will return a list of image formats that
          are available for both reading and writing in kernel code.
          The returned WebCLImageDescriptor objects will only have the
          `channelOrder` and `channelType` fields filled in; the other
          fields will have their default value (zero).
        </p>

        <p>
          The minimum set of image formats that must be supported (for
          both reading and writing) by all devices is defined in the
          table below.  Note that the set of required formats is the
          same as on OpenCL 1.1 Embedded Profile.
       </p>

        <table class="enumtable">
          <tr><th>channelOrder</th><th>channelType</th></tr>
          <tr><td>RGBA</td>
            <td>UNORM_INT8<br>
        		  UNORM_INT16<br>
						  SIGNED_INT8<br>
						  SIGNED_INT16<br>
						  SIGNED_INT32<br>
						  UNSIGNED_INT8<br>
						  UNSIGNED_INT16<br>
						  UNSIGNED_INT32<br>
						  HALF_FLOAT<br>
						  FLOAT</td></tr>
        </table>

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if `memFlags` is not `MEM_READ_WRITE`, `MEM_WRITE_ONLY`, or `MEM_READ_ONLY`</li>
        </ul>
      </dd>

      <dt class="idl-code">void release()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=48">OpenCL 1.1 §4.3</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clReleaseContext.html">clReleaseContext</a>)</span>
      </dt>
      <dd>
        Releases the resources held up by this object.
      </dd>

      <dt class="idl-code">void releaseAll()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=48">OpenCL 1.1 §4.3</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clReleaseContext.html">clReleaseContext</a>)</span>
      </dt>
      <dd>
        Releases the resources held up by this WebCLContext and all
        objects created from it, if any.
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h4><a id="WEBCLIMAGEDESCRIPTOR">WebCLImageDescriptor</a></h4>

<pre class="idl">
dictionary <dfn>WebCLImageDescriptor</dfn> {
  CLenum channelOrder = WebCL.RGBA;            
  CLenum channelType = WebCL.UNORM_INT8;
  CLuint width = 0;
  CLuint height = 0;
  CLuint rowPitch = 0;
};
</pre>

<!-- ======================================================================================================= -->

    <h3><a id="WEBCLCOMMANDQUEUE">WebCLCommandQueue</a></h3>

<pre class="idl">
interface <dfn>WebCLCommandQueue</dfn> {

  ////////////////////////////////////////////////////////////////////////////
  //
  // Copying: Buffer &lt;-&gt; Buffer, Image &lt;-&gt; Image, Buffer &lt;-&gt; Image
  //

  void enqueueCopyBuffer(
                    WebCLBuffer                           srcBuffer,
                    WebCLBuffer                           dstBuffer,
                    CLuint                                srcOffset,
                    CLuint                                dstOffset,
                    CLuint                                numBytes,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList = null,
                    optional WebCLEvent?                  event = null);

  void enqueueCopyBufferRect(
                    WebCLBuffer                           srcBuffer,
                    WebCLBuffer                           dstBuffer,
                    sequence&lt;CLuint&gt;                      srcOrigin,
                    sequence&lt;CLuint&gt;                      dstOrigin,
                    sequence&lt;CLuint&gt;                      region,
                    CLuint                                srcRowPitch,
                    CLuint                                srcSlicePitch,
                    CLuint                                dstRowPitch,
                    CLuint                                dstSlicePitch,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList = null,
                    optional WebCLEvent?                  event = null);

  void enqueueCopyImage(
                    WebCLImage                            srcImage,
                    WebCLImage                            dstImage,
                    sequence&lt;CLuint&gt;                      srcOrigin,
                    sequence&lt;CLuint&gt;                      dstOrigin,
                    sequence&lt;CLuint&gt;                      region,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList = null,
                    optional WebCLEvent?                  event = null);

  void enqueueCopyImageToBuffer(
                    WebCLImage                            srcImage,
                    WebCLBuffer                           dstBuffer,
                    sequence&lt;CLuint&gt;                      srcOrigin,
                    sequence&lt;CLuint&gt;                      srcRegion,
                    CLuint                                dstOffset,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList = null,
                    optional WebCLEvent?                  event = null);

  void enqueueCopyBufferToImage(
                    WebCLBuffer                           srcBuffer,
                    WebCLImage                            dstImage,
                    CLuint                                srcOffset,
                    sequence&lt;CLuint&gt;                      dstOrigin,
                    sequence&lt;CLuint&gt;                      dstRegion,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList = null,
                    optional WebCLEvent?                  event = null);

  ////////////////////////////////////////////////////////////////////////////
  //
  // Reading: Buffer -> Host, Image -> Host
  //

  void enqueueReadBuffer(
                    WebCLBuffer                           buffer,
                    CLboolean                             blockingRead,
                    CLuint                                bufferOffset,
                    CLuint                                numBytes,
                    ArrayBufferView                       hostPtr,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList = null,
                    optional WebCLEvent?                  event = null);

  void enqueueReadBufferRect(
                    WebCLBuffer                           buffer,
                    CLboolean                             blockingRead,
                    sequence&lt;CLuint&gt;                      bufferOrigin,
                    sequence&lt;CLuint&gt;                      hostOrigin,
                    sequence&lt;CLuint&gt;                      region,
                    CLuint                                bufferRowPitch,
                    CLuint                                bufferSlicePitch,
                    CLuint                                hostRowPitch,
                    CLuint                                hostSlicePitch,
                    ArrayBufferView                       hostPtr,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList = null,
                    optional WebCLEvent?                  event = null);

  void enqueueReadImage(
                    WebCLImage                            image,
                    CLboolean                             blockingRead,
                    sequence&lt;CLuint&gt;                      origin,
                    sequence&lt;CLuint&gt;                      region,
                    CLuint                                hostRowPitch,
                    ArrayBufferView                       hostPtr,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList = null,
                    optional WebCLEvent?                  event = null);

  ////////////////////////////////////////////////////////////////////////////
  //
  // Writing: Host -> Buffer, Host -> Image
  //

  void enqueueWriteBuffer(
                    WebCLBuffer                           buffer,
                    CLboolean                             blockingWrite,
                    CLuint                                bufferOffset,
                    CLuint                                numBytes,
                    ArrayBufferView                       hostPtr,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList = null,
                    optional WebCLEvent?                  event = null);

  void enqueueWriteBufferRect(
                    WebCLBuffer                           buffer,
                    CLboolean                             blockingWrite,
                    sequence&lt;CLuint&gt;                      bufferOrigin,
                    sequence&lt;CLuint&gt;                      hostOrigin,
                    sequence&lt;CLuint&gt;                      region,
                    CLuint                                bufferRowPitch,
                    CLuint                                bufferSlicePitch,
                    CLuint                                hostRowPitch,
                    CLuint                                hostSlicePitch,
                    ArrayBufferView                       hostPtr,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList = null,
                    optional WebCLEvent?                  event = null);

  void enqueueWriteImage(
                    WebCLImage                            image,
                    CLboolean                             blockingWrite,
                    sequence&lt;CLuint&gt;                      origin,
                    sequence&lt;CLuint&gt;                      region,
                    CLuint                                hostRowPitch,
                    ArrayBufferView                       hostPtr,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList = null,
                    optional WebCLEvent?                  event = null);

  ////////////////////////////////////////////////////////////////////////////
  //
  // Executing kernels
  //

  void enqueueNDRangeKernel(
                    WebCLKernel                           kernel,
                    CLuint                                workDim,
                    sequence&lt;CLuint&gt;?                     globalWorkOffset = null, 
                    sequence&lt;CLuint&gt;                      globalWorkSize,
                    optional sequence&lt;CLuint&gt;?            localWorkSize = null,
                    optional sequence&lt;WebCLEvent&gt;?        eventWaitList = null,
                    optional WebCLEvent?                  event = null);

  ////////////////////////////////////////////////////////////////////////////
  //
  // Synchronization
  //

  void enqueueMarker(WebCLEvent event);

  void enqueueBarrier();

  void enqueueWaitForEvents (sequence&lt;WebCLEvent&gt; eventWaitList);
  
  void finish(optional WebCLCallback whenFinished);

  void flush();

  ////////////////////////////////////////////////////////////////////////////
  //
  // Querying command queue information
  //

  any getInfo(CLenum name);

  void release();
};
</pre>

    <dl class="methods">

      <dt class="idl-code">void enqueueCopyBuffer(
        WebCLBuffer             srcBuffer,
        WebCLBuffer             dstBuffer,
        CLuint                  srcOffset,
        CLuint                  dstOffset,
        CLuint                  numBytes,
        optional sequence&lt;WebCLEvent&gt;?  eventWaitList = null,
        optional WebCLEvent?    event = null)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 §5.2.2</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueCopyBuffer.html">clEnqueueCopyBuffer</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
	        <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not
	          associated with the same WebCLContext as `srcBuffer` and
	          `dstBuffer`</li>
	        <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not
	          associated with the same WebCLContext as all events in
	          `eventWaitList`</li>
	        <li>`INVALID_MEM_OBJECT` -- if `srcBuffer` and `dstBuffer`
	          are not valid WebCLBuffer objects</li>
	        <li>`INVALID_VALUE` -- if `srcOffset`, `dstOffset`,
	          `numBytes`, `srcOffset`+`numBytes`, or
	          `dstOffset`+`numBytes` require accessing elements outside
	          the `srcBuffer` and `dstBuffer` buffer objects
	          respectively
	        <li>`INVALID_EVENT_WAIT_LIST` -- if any event in
	          `eventWaitList` is invalid</li>
          <li>`INVALID_EVENT` -- if `event` is not a newly created empty WebCLEvent</li>
	        <li>`MEM_COPY_OVERLAP` -- if `srcBuffer` and `dstBuffer` are
	          the same WebCLBuffer object and the source and destination
	          regions overlap</li>
	        <li>`MEM_OBJECT_ALLOCATION_FAILURE` -- if there is a failure
	          to allocate memory for data store associated with
	          `srcBuffer` or `dstBuffer`</li>
        </ul>
      </dd>

      <dt class="idl-code">void enqueueCopyBufferRect(
        WebCLBuffer             srcBuffer,
        WebCLBuffer             dstBuffer,
        sequence&lt;CLuint&gt;               srcOrigin,
        sequence&lt;CLuint&gt;               dstOrigin,
        sequence&lt;CLuint&gt;               region,
        CLuint                  srcRowPitch,
        CLuint                  srcSlicePitch,
        CLuint                  dstRowPitch,
        CLuint                  dstSlicePitch,
        optional sequence&lt;WebCLEvent&gt;?  eventWaitList = null,
        optional WebCLEvent?    event = null)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 §5.2.2</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueCopyBufferRect.html">clEnqueueCopyBufferRect</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not associated with the same WebCLContext as `srcBuffer` and `dstBuffer`</li>
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not associated with the same WebCLContext as all events in `eventWaitList`</li>
          <li>`INVALID_MEM_OBJECT` -- if `srcBuffer` and `dstBuffer` are not valid WebCLBuffer objects</li>
          <li>`INVALID_VALUE` -- if `srcOrigin`, `dstOrigin`, or `region` does not have exactly three elements</li>
          <li>`INVALID_VALUE` -- if the `origin`, `region` and `pitch`
            values would require accessing elements outside the
            `srcBuffer` or `dstBuffer` objects</li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if any event in
          `eventWaitList` is invalid</li>
          <li>`INVALID_EVENT` -- if `event` is not a newly created empty WebCLEvent</li>
          <li>`MEM_COPY_OVERLAP` -- if `srcBuffer` and `dstBuffer` are
            the same WebCLBuffer object and the source and destination
            regions overlap</li>
        </ul>
      </dd>

      <dt class="idl-code">void enqueueCopyImage(
        WebCLImage              srcImage,
        WebCLImage              dstImage,
        sequence&lt;CLuint&gt;               srcOrigin,
        sequence&lt;CLuint&gt;               dstOrigin,
        sequence&lt;CLuint&gt;               region,
        optional sequence&lt;WebCLEvent&gt;?  eventWaitList = null,
        optional WebCLEvent?    event = null)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 §5.2.2</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueCopyImage.html">clEnqueueCopyImage</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
	        <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not
	          associated with the same WebCLContext as `srcImage` and
	          `dstImage`</li>
	        <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not
	          associated with the same WebCLContext as all events in
	          `eventWaitList`</li>
	        <li>`INVALID_MEM_OBJECT` -- if `srcImage` or `dstImage` is
	          not a valid image object</li>
	        <li>`IMAGE_FORMAT_MISMATCH` -- if `srcImage` and `dstImage`
	          do not have the same image format</li>
	        <li>`INVALID_VALUE` -- if the `srcOrigin`, `dstOrigin` and
            `region` values would require accessing elements outside
            the boundaries of `srcImage` or `dstImage`</li>
          <li>`INVALID_VALUE` -- if `srcOrigin`, `dstOrigin`, or
            `region` does not have exactly two elements</li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if any event in
            `eventWaitList` is invalid</li>
          <li>`INVALID_EVENT` -- if `event` is not a newly created empty WebCLEvent</li>
	        <li>`INVALID_IMAGE_SIZE` -- if the image dimensions of
            `srcImage` or `dstImage` are not supported by the device
            associated with this WebCLCommandQueue</li>
	        <li>`MEM_OBJECT_ALLOCATION_FAILURE` -- if there is a failure
	          to allocate memory for data store associated with
	          `srcImage` or `dstImage`</li>
	        <li>`MEM_COPY_OVERLAP` -- if `srcImage` and `dstImage` are
	          the same WebCLImage object and the source and destination
	          regions overlap</li>
        </ul>
      </dd>

      <dt class="idl-code">void enqueueCopyBufferToImage(
        WebCLBuffer             srcBuffer,
        WebCLImage              dstImage,
        CLuint                  srcOffset,
        sequence&lt;CLuint&gt;               dstOrigin,
        sequence&lt;CLuint&gt;               dstRegion,
        optional sequence&lt;WebCLEvent&gt;?  eventWaitList = null,
        optional WebCLEvent?    event = null)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.3.4">OpenCL 1.1 §5.3.4</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueCopyBufferToImage.html">clEnqueueCopyBufferToImage</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
	        <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not
	          associated with the same WebCLContext as `srcBuffer` and
	          `dstImage`</li>
	        <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not
	          associated with the same WebCLContext as all events in
	          `eventWaitList`</li>
	        <li>`INVALID_MEM_OBJECT` -- if `srcBuffer` is not a valid
            buffer object or `dstImage` is not a valid image
            object</li>
          <li>`INVALID_VALUE` -- if `dstOrigin` or `dstRegion` does
            not have exactly two elements</li>
	        <li>`INVALID_VALUE` -- if the `srcOffset`, `dstOrigin` and
            `dstRegion` values would require accessing elements
            outside the boundaries of `srcBuffer` or `dstImage`</li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if any event in
            `eventWaitList` is invalid</li>
          <li>`INVALID_EVENT` -- if `event` is not a newly created empty WebCLEvent</li>
	        <li>`INVALID_IMAGE_SIZE` -- if the image dimensions of
            `dstImage` are not supported by the device associated with
            this WebCLCommandQueue</li>
	        <li>`MEM_OBJECT_ALLOCATION_FAILURE` -- if there is a failure
	          to allocate memory for data store associated with
	          `srcBuffer` or `dstImage`</li>
        </ul>
      </dd>

      <dt class="idl-code">void enqueueCopyImageToBuffer(
        WebCLImage              srcImage,
        WebCLBuffer             dstBuffer,
        sequence&lt;CLuint&gt;               srcOrigin,
        sequence&lt;CLuint&gt;               srcRegion,
        CLuint                  dstOffset,
        optional sequence&lt;WebCLEvent&gt;?  eventWaitList = null,
        optional WebCLEvent?    event = null)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.3.4">OpenCL 1.1 §5.3.4</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueCopyImageToBuffer.html">clEnqueueCopyImageToBuffer</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
	        <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not
	          associated with the same WebCLContext as `srcImage` and
	          `dstBuffer`</li>
	        <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not
	          associated with the same WebCLContext as all events in
	          `eventWaitList`</li>
	        <li>`INVALID_MEM_OBJECT` -- if `srcImage` is not a valid
            image object or `dstBuffer` is not a valid buffer
            object</li>
          <li>`INVALID_VALUE` -- if `srcOrigin` or `srcRegion` does
            not have exactly two elements</li>
	        <li>`INVALID_VALUE` -- if the `srcOrigin`, `srcRegion` and
            `dstOffset` values would require accessing elements
            outside the boundaries of `srcImage` or `dstBuffer`</li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if any event in
            `eventWaitList` is invalid</li>
          <li>`INVALID_EVENT` -- if `event` is not a newly created empty WebCLEvent</li>
	        <li>`INVALID_IMAGE_SIZE` -- if the image dimensions of
            `srcImage` are not supported by the device associated with
            this WebCLCommandQueue</li>
	        <li>`MEM_OBJECT_ALLOCATION_FAILURE` -- if there is a failure
	          to allocate memory for data store associated with
	          `srcImage` or `dstBuffer`</li>
        </ul>
      </dd>

      <dt class="idl-code">void enqueueReadBuffer(
        WebCLBuffer             buffer,
        CLboolean               blockingRead,
        CLuint                  bufferOffset,
        CLuint                  numBytes,
        ArrayBufferView         hostPtr,
        optional sequence&lt;WebCLEvent&gt;?  eventWaitList = null,
        optional WebCLEvent?    event = null)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 §5.2.2</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueReadBuffer.html">clEnqueueReadBuffer</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_OPERATION` -- if the blocking form of this function is called from a WebCLCallback</li>
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not
            associated with the same WebCLContext as `buffer`</li>
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not
            associated with the same WebCLContext as all events in
            `eventWaitList`</li>
          <li>`INVALID_MEM_OBJECT` -- if `buffer` is not a valid
            buffer object</li>
          <li>`INVALID_VALUE` -- if any part of the region being read,
            specified by `bufferOffset` and `numBytes`, is out of
            bounds of `buffer`</li>
          <li>`INVALID_VALUE` -- if any part of the region being
            written, specified by `hostPtr` and `numBytes` is out of
            bounds of `hostPtr`</li>
          <li>`INVALID_VALUE` -- if <code>numBytes %
            hostPtr.BYTES_PER_ELEMENT !== 0</code></li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if any event in `eventWaitList` is invalid</li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if `blockingRead` is `true`, and any event in
            `eventWaitList` is a WebCLUserEvent or a newly created (non-activated) WebCLEvent</li>
          <li>`EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST` -- if
            `blockingRead` is `true` and the execution status of any
            event in `eventWaitList` is a negative integer value</li>
          <li>`INVALID_EVENT` -- if `event` is not a newly created empty WebCLEvent</li>
        </ul>
      </dd>

      <dt class="idl-code">void enqueueReadBufferRect(
        WebCLBuffer             buffer,
        CLboolean               blockingRead,
        sequence&lt;CLuint&gt;               bufferOrigin,
        sequence&lt;CLuint&gt;               hostOrigin,
        sequence&lt;CLuint&gt;               region,
        CLuint                  bufferRowPitch,
        CLuint                  bufferSlicePitch,
        CLuint                  hostRowPitch,
        CLuint                  hostSlicePitch,
        ArrayBufferView         hostPtr,
        optional sequence&lt;WebCLEvent&gt;?  eventWaitList = null,
        optional WebCLEvent?    event = null)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 §5.2.2</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueReadBufferRect.html">clEnqueueReadBufferRect</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_OPERATION` -- if the blocking form of this function is called from a WebCLCallback</li>
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not associated with the same WebCLContext as `buffer`</li>
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not associated with the same WebCLContext as all events in `eventWaitList`</li>
          <li>`INVALID_MEM_OBJECT` -- if `buffer` is not a valid WebCLBuffer object</li>
          <li>`INVALID_VALUE` -- if `bufferOrigin`, `hostOrigin`, or
            `region` does not have exactly three elements</li>
          <li>`INVALID_VALUE` -- if any part of the region being read,
            specified by `bufferOrigin`, `region`, `bufferRowPitch` and
            `bufferSlicePitch`, is out of bounds of `buffer`</li>
          <li>`INVALID_VALUE` -- if any part of the region being
            written, specified by `hostOrigin`, `region`, `hostRowPitch`
            and `hostSlicePitch`, is out of bounds of `hostPtr`</li>
          <li>`INVALID_VALUE` -- if <code>host{Row,Slice}Pitch %
            hostPtr.BYTES_PER_ELEMENT !== 0</code></li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if any event in `eventWaitList` is invalid</li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if `blockingRead` is `true`, and any event in
            `eventWaitList` is a WebCLUserEvent or a newly created (non-activated) WebCLEvent</li>
          <li>`EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST` -- if
            `blockingRead` is `true` and the execution status of any
            event in `eventWaitList` is a negative integer value</li>
          <li>`INVALID_EVENT` -- if `event` is not a newly created empty WebCLEvent</li>
        </ul>
      </dd>

      <dt class="idl-code">void enqueueReadImage(
        WebCLImage              image,
        CLboolean               blockingRead,
        sequence&lt;CLuint&gt;               origin,
        sequence&lt;CLuint&gt;               region,
        CLuint                  hostRowPitch,
        ArrayBufferView         hostPtr,
        optional sequence&lt;WebCLEvent&gt;?  eventWaitList = null,
        optional WebCLEvent?    event = null)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 §5.2.2</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueReadImage.html">clEnqueueReadImage</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_OPERATION` -- if the blocking form of this function is called from a WebCLCallback</li>
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not associated with the same WebCLContext as `image`</li>
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not associated with the same WebCLContext as all events in `eventWaitList`</li>
          <li>`INVALID_MEM_OBJECT` -- if `image` is not a valid WebCLImage object</li>
          <li>`INVALID_IMAGE_SIZE` -- if the image dimensions of `image` are not supported by this WebCLCommandQueue</li>
          <li>`INVALID_VALUE` -- if `origin` or `region` does not have exactly two elements</li>
          <li>`INVALID_VALUE` -- if any part of the region being read, specified by `origin` and `region`, is out of bounds of `image`</li>
          <li>`INVALID_VALUE` -- if any part of the region being written, specified by `region` and `hostRowPitch`, is out of bounds of `hostPtr`</li>
          <li>`INVALID_VALUE` -- if <code>hostRowPitch % hostPtr.BYTES_PER_ELEMENT !== 0</code></li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if any event in `eventWaitList` is invalid</li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if `blockingRead` is `true`, and any event in
            `eventWaitList` is a WebCLUserEvent or a newly created (non-activated) WebCLEvent</li>
          <li>`EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST` -- if `blockingRead` is `true` and the execution status of any event
            in `eventWaitList` is a negative integer value</li>
          <li>`INVALID_EVENT` -- if `event` is not a newly created empty WebCLEvent</li>
        </ul>
      </dd>

      <dt class="idl-code">void enqueueWriteBuffer(
        WebCLBuffer             buffer,
        CLboolean               blockingWrite,
        CLuint                  bufferOffset,
        CLuint                  numBytes,
        ArrayBufferView         hostPtr,
        optional sequence&lt;WebCLEvent&gt;?  eventWaitList = null,
        optional WebCLEvent?    event = null)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 §5.2.2</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueWriteBuffer.html">clEnqueueWriteBuffer</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_OPERATION` -- if the blocking form of this function is called from a WebCLCallback</li>
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not
            associated with the same WebCLContext as `buffer`</li>
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not
            associated with the same WebCLContext as all events in
            `eventWaitList`</li>
          <li>`INVALID_MEM_OBJECT` -- if `buffer` is not a valid
            buffer object</li>
          <li>`INVALID_VALUE` -- if any part of the region being
            written, specified by `bufferOffset` and `numBytes`, is
            out of bounds of `buffer`</li>
          <li>`INVALID_VALUE` -- if any part of the region being read,
            specified by `hostPtr` and `numBytes`, is out of bounds of
            `hostPtr`</li>
          <li>`INVALID_VALUE` -- if <code>numBytes %
            hostPtr.BYTES_PER_ELEMENT !== 0</code></li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if any event in `eventWaitList` is invalid</li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if `blockingWrite` is `true`, and any event in
            `eventWaitList` is a WebCLUserEvent or a newly created (non-activated) WebCLEvent</li>
          <li>`EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST` -- if
            `blockingWrite` is `true` and the execution status of any
            event in `eventWaitList` is a negative integer value</li>
          <li>`INVALID_EVENT` -- if `event` is not a newly created empty WebCLEvent</li>
        </ul>
      </dd>

      <dt class="idl-code">void enqueueWriteBufferRect(
        WebCLBuffer             buffer,
        CLboolean               blockingWrite,
        sequence&lt;CLuint&gt;               bufferOrigin,
        sequence&lt;CLuint&gt;               hostOrigin,
        sequence&lt;CLuint&gt;               region,
        CLuint                  bufferRowPitch,
        CLuint                  bufferSlicePitch,
        CLuint                  hostRowPitch,
        CLuint                  hostSlicePitch,
        ArrayBufferView         hostPtr,
        optional sequence&lt;WebCLEvent&gt;?  eventWaitList = null,
        optional WebCLEvent?    event = null)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 §5.2.2</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueWriteBufferRect.html">clEnqueueWriteBufferRect</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_OPERATION` -- if the blocking form of this function is called from a WebCLCallback</li>
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not associated with the same WebCLContext as `buffer`</li>
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not associated with the same WebCLContext as all events in `eventWaitList`</li>
          <li>`INVALID_MEM_OBJECT` -- if `buffer` is not a valid WebCLBuffer object</li>
          <li>`INVALID_VALUE` -- if `bufferOrigin`, `hostOrigin`, or
            `region` does not have exactly three elements</li>
          <li>`INVALID_VALUE` -- if any part of the region being written,
            specified by `bufferOrigin`, `region`, `bufferRowPitch` and
            `bufferSlicePitch`, is out of bounds of `buffer`</li>
          <li>`INVALID_VALUE` -- if any part of the region being
            read, specified by `hostOrigin`, `region`, `hostRowPitch`
            and `hostSlicePitch`, is out of bounds of `hostPtr`</li>
          <li>`INVALID_VALUE` -- if <code>host{Row,Slice}Pitch %
            hostPtr.BYTES_PER_ELEMENT !== 0</code></li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if any event in `eventWaitList` is invalid</li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if `blockingWrite` is `true`, and any event in
            `eventWaitList` is a WebCLUserEvent or a newly created (non-activated) WebCLEvent</li>
          <li>`EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST` -- if
            `blockingWrite` is `true` and the execution status of any
            event in `eventWaitList` is a negative integer value</li>
          <li>`INVALID_EVENT` -- if `event` is not a newly created empty WebCLEvent</li>
        </ul>
      </dd>

      <dt class="idl-code">void enqueueWriteImage(
        WebCLImage              image,
        CLboolean               blockingWrite,
        sequence&lt;CLuint&gt;               origin,
        sequence&lt;CLuint&gt;               region,
        CLuint                  hostRowPitch,
        ArrayBufferView         hostPtr,
        optional sequence&lt;WebCLEvent&gt;?  eventWaitList = null,
        optional WebCLEvent?    event = null)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.2">OpenCL 1.1 §5.2.2</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueWriteImage.html">clEnqueueWriteImage</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_OPERATION` -- if the blocking form of this function is called from a WebCLCallback</li>
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not associated with the same WebCLContext as `image`</li>
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not associated with the same WebCLContext as all events in `eventWaitList`</li>
          <li>`INVALID_MEM_OBJECT` -- if `image` is not a valid WebCLImage object</li>
          <li>`INVALID_IMAGE_SIZE` -- if the image dimensions of `image` are not supported by this WebCLCommandQueue</li>
          <li>`INVALID_VALUE` -- if `origin` or `region` does not have exactly two elements</li>
          <li>`INVALID_VALUE` -- if any part of the region being written, specified by `origin` and `region`, is out of bounds of `image`</li>
          <li>`INVALID_VALUE` -- if any part of the region being read, specified by `region` and `hostRowPitch`, is out of bounds of `hostPtr`</li>
          <li>`INVALID_VALUE` -- if <code>hostRowPitch % hostPtr.BYTES_PER_ELEMENT !== 0</code></li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if any event in `eventWaitList` is invalid</li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if `blockingWrite` is `true`, and any event in
            `eventWaitList` is a WebCLUserEvent or a newly created (non-activated) WebCLEvent</li>
          <li>`EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST` -- if
            `blockingWrite` is `true` and the execution status of any
            event in `eventWaitList` is a negative integer value</li>
          <li>`INVALID_EVENT` -- if `event` is not a newly created empty WebCLEvent</li>
        </ul>
      </dd>

      <dt class="idl-code">void enqueueNDRangeKernel( 
        WebCLKernel kernel,
        CLuint workDim,
        sequence&lt;CLuint&gt;? globalWorkOffset = null,
        sequence&lt;CLuint&gt; globalWorkSize,
        optional sequence&lt;CLuint&gt;? localWorkSize = null,
        optional sequence&lt;WebCLEvent&gt;? eventWaitList = null,
        optional WebCLEvent? event = null)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.8">OpenCL 1.1 §5.8</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueNDRangeKernel.html">clEnqueueNDRangeKernel</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not associated with the same WebCLContext as `kernel`</li>
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not associated with the same WebCLContext as all events in `eventWaitList`</li>
          <li>`INVALID_KERNEL` -- if `kernel` is not a valid WebCLKernel object</li>
          <li>`INVALID_PROGRAM_EXECUTABLE` -- if there is no
            successfully built program executable of `kernel`
            available for the device associated with this
            WebCLCommandQueue</li>
          <li>`INVALID_KERNEL_ARGS` -- if any kernel argument values have not been specified for `kernel`</li>
          <li>`INVALID_WORK_DIMENSION` -- if `workDim` is not equal to 1, 2, or 3</li>
          <li>`INVALID_GLOBAL_WORK_SIZE` -- if <code>globalWorkSize.length != workDim</code></li>
          <li>`INVALID_GLOBAL_WORK_SIZE` -- if <code>globalWorkSize[i] &gt; 2<small><sup>32</sup></small>-1</code> for any `i`</li>
          <li>`INVALID_GLOBAL_OFFSET` -- if <code>globalWorkOffset != null && (globalWorkOffset.length != workDim)</code></li>
          <li>`INVALID_GLOBAL_OFFSET` -- if <code>globalWorkOffset != null && (globalWorkSize[i] +
            globalWorkOffset[i] &gt; 2<small><sup>32</sup></small>-1)</code> for any `i`</li>
          <li>`INVALID_WORK_GROUP_SIZE` -- if <code>localWorkSize != null && (localWorkSize.length != workDim)</code></li>
          <li>`INVALID_WORK_GROUP_SIZE` -- if <code>localWorkSize != null && (globalWorkSize[i] % localWorkSize[i] !== 0)</code> for any `i`</li>
          <li>`INVALID_WORK_GROUP_SIZE` -- if <code>localWorkSize != null && (localWorkSize[i] !== requiredSize[i])</code> for any `i`, where
            `requiredSize` is specified using the `reqd_work_group_size` qualifier in kernel source</li>
          <li>`INVALID_WORK_GROUP_SIZE` -- if <code>localWorkSize != null</code> and the total
            number of work-items in a work-group (that is, the product of all elements in
            `localWorkSize`) is greater than the value of `DEVICE_MAX_WORK_GROUP_SIZE` queried from
            the device associated with this queue</li>
          <li>`INVALID_WORK_GROUP_SIZE` -- if <code>localWorkSize == null</code> and the
            `reqd_work_group_size` qualifier is present in kernel source</li>
          <li>`INVALID_WORK_ITEM_SIZE` -- if <code>localWorkSize != null && (localWorkSize[i] &gt; DEVICE_MAX_WORK_ITEM_SIZES[i])</code> for any `i`</li>
          <li>`INVALID_IMAGE_SIZE` -- if an image object is specified as an argument to `kernel`, and the image dimensions
            (width, height, pitch) are not supported by the device associated with this queue</li>
          <li>`MEM_OBJECT_ALLOCATION_FAILURE` -- if there is a failure to allocate memory for data store associated with
            image or buffer objects specified as arguments to `kernel`</li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if any event in `eventWaitList` is invalid</li>
          <li>`INVALID_EVENT` -- if `event` is not a newly created empty WebCLEvent</li>
        </ul>
      </dd>

      <dt class="idl-code">void enqueueMarker(WebCLEvent event)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.10">OpenCL 1.1 §5.10</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueMarker.html">clEnqueueMarker</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_EVENT` -- if `event` is not a newly created empty WebCLEvent</li>
        </ul>
      </dd>

      <dt class="idl-code">void enqueueBarrier()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.10">OpenCL 1.1 §5.10</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueBarrier.html">clEnqueueBarrier</a>)</span>
      </dt>
      <dd>
      </dd>

      <dt class="idl-code">void enqueueWaitForEvents (sequence&lt;WebCLEvent&gt; eventWaitList);
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.10">OpenCL 1.1 §5.10</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueWaitForEvents.html">clEnqueueWaitForEvents</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_CONTEXT` -- if this WebCLCommandQueue is not associated with the same WebCLContext as all events in `eventWaitList`</li>
          <li>`INVALID_VALUE` -- if `eventWaitList` is empty</li>
          <li>`INVALID_EVENT_WAIT_LIST` -- if `eventWaitList` contains any invalid events</li>
        </ul>
      </dd>

      <dt class="idl-code">void finish(optional WebCLCallback whenFinished)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.13">OpenCL 1.1 §5.13</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clFinish.html">clFinish</a>)</span>
      </dt>
      <dd>
        Invokes the given callback when all commands in this queue have completed.  If a callback is
        not provided, the JavaScript main thread will be blocked until the commands have completed.
        Applications are strongly advised to provide a callback; the blocking mode mainly exists to
        ease the porting of existing OpenCL code.

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_OPERATION` -- if the blocking form of this function is called from a WebCLCallback</li>
        </ul>
      </dd>

      <dt class="idl-code">void flush()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.13">OpenCL 1.1 §5.13</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clFlush.html">clFlush</a>)</span>
      </dt>
      <dd>
      </dd>

      <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.1">OpenCL 1.1 §5.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetCommandQueueInfo.html">clGetCommandQueueInfo</a>)</span>
      </dt>
      <dd>
        <table class="enumtable">
          <tr><th>name</th><th>return type</th></tr>
          <tr><td>QUEUE_CONTEXT</td><td>WebCLContext</td></tr>
          <tr><td>QUEUE_DEVICE</td><td>WebCLDevice</td></tr>
          <tr><td>QUEUE_PROPERTIES</td><td>CLenum</td></tr>
        </table>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if `name` is not one of the valid enumerated values listed in the table above</li>
        </ul>
      </dd>

      <dt class="idl-code">void release()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=53">OpenCL 1.1 §5.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clReleaseCommandQueue.html">clReleaseCommandQueue</a>)</span>
      </dt>
      <dd>
        Releases the resources held up by this object.
      </dd>

    </dl>

<pre class="example">
// This example shows how to wait for two kernels to complete before a
// third kernel executes

var eventWaitList = [ new WebCLEvent(), new WebCLEvent() ];
queue.enqueueNDRangeKernel(kernel1, dim, null, globals, null, null, eventWaitList[0]);
queue.enqueueNDRangeKernel(kernel2, dim, null, globals, null, null, eventWaitList[1]);
queue.enqueueNDRangeKernel(kernel3, dim, null, globals, null, eventWaitList);
</pre>

<pre class="example">
// This example reads the entire contents of a WebCL buffer object
// into a newly created Uint8Array in host memory.

function readBufferToHost(srcBuffer) {

 // Query the number of bytes in the source buffer, create a new
 // Uint8Array of that size, then fill it with a blocking read.

 var numBytes = srcBuffer.getInfo(WebCL.MEM_SIZE);
 var dstArray = new Uint8Array(numBytes);
 queue.enqueueReadBuffer(srcBuffer, true, 0, numBytes, dstArray);

 return dstArray;
};
</pre>

<pre class="example">
// This example fills a WebCL image with pixels from a WebCL buffer.

function copyBufferToImage(srcBuffer, dstImage) {

  // Extract the dimensions of the image.

  var imgWidth = dstImage.getInfo(WebCL.IMAGE_WIDTH);
  var imgHeight = dstImage.getInfo(WebCL.IMAGE_HEIGHT);
  queue.enqueueCopyBufferToImage(srcBuffer, dstImage, 0, [0,0], [imgWidth, imgHeight]);
};
</pre>

<pre class="example">
// This example copies a rectangular region of memory from a
// buffer object to another.  The buffer objects are assumed
// to be the same size. The origin, width, height, and pitch
// (a.k.a. row stride) are given in bytes (not pixels, because
// these are buffers rather than images).

function copyBufferRect(srcBuffer, dstBuffer, srcX, srcY, dstX, dstY, w, h, pitch) {

  // The row pitch could be different for source and destination,
  // but is assumed to be the same in this example.

  queue.enqueueCopyBufferRect(srcBuffer, dstBuffer, [srcX, srcY], [dstX, dstY], 
                              [w, h], pitch, 0, pitch, 0);
};
</pre>


<!-- ======================================================================================================= -->

    <h3><a id="WEBCLMEMORYOBJECT">WebCLMemoryObject</a></h3>

<pre class="idl">interface <dfn>WebCLMemoryObject</dfn> {
  any getInfo(CLenum name);
  void release();
};
</pre>

    <dl class="methods">
      <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=103">OpenCL 1.1 §5.4.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetMemObjectInfo.html">clGetMemObjectInfo</a>)</span>
      </dt>
      <dd>
        <table class="enumtable">
          <tr><th>name</th><th>return type</th><th>return value</th></tr>
          <tr><td>`MEM_TYPE`</td><td>`CLenum`</td><td>`MEM_OBJECT_BUFFER` or `MEM_OBJECT_IMAGE2D`</td></tr>
          <tr><td>`MEM_FLAGS`</td><td>`CLenum`</td><td>The `memFlags` as specified at construction time</td></tr>
          <tr><td>`MEM_SIZE`</td><td>`CLuint`</td><td>The size of this memory object in bytes</td></tr>
          <tr><td>`MEM_CONTEXT`</td><td>`WebCLContext`</td><td>the WebCL context of this memory object</td></tr>
          <tr><td>`MEM_ASSOCIATED_MEMOBJECT`</td><td>`WebCLBuffer`</td><td>The buffer
              object that this buffer was created from, or `null`
              if this buffer was not created using `createSubBuffer`</td></tr>
          <tr><td>`MEM_OFFSET`</td><td>`CLuint`</td><td>The offset given to `createSubBuffer`,
              or zero if this buffer was not created using `createSubBuffer`</td></tr>
        </table>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if `name` is not one of the valid enumerated values listed in the table above</li>
        </ul>
      </dd>

      <dt class="idl-code">void release()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=99">OpenCL 1.1 §5.4.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clReleaseMemObject.html">clReleaseMemObject</a>)</span>
      </dt>
      <dd>
        Releases the resources held up by this object.
      </dd>

    </dl>

<!-- ======================================================================================================= -->

    <h4><a id="WEBCLBUFFER">WebCLBuffer</a></h4>

     <p>
     </p>

<pre class="idl">interface <dfn>WebCLBuffer</dfn> : WebCLMemoryObject {
  WebCLBuffer createSubBuffer(CLenum memFlags, CLuint origin, CLuint sizeInBytes);
};
</pre>

    <dl class="methods">
      <dt class="idl-code">WebCLBuffer createSubBuffer(CLenum memFlags, CLuint origin, CLuint sizeInBytes)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.2.1">OpenCL 1.1 §5.2.1</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateSubBuffer.html">clCreateSubBuffer</a>)</span>
      </dt>
      <dd>
        Creates a new WebCLBuffer that represents a sub-region of this
        WebCLBuffer. The two buffers reference the same area of global
        memory, so changes made into one are immediately reflected in
        the other.
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_MEM_OBJECT` -- if this WebCLBuffer is already a sub-buffer object</li>
          <li>`INVALID_VALUE` -- if `memFlags` is not `MEM_READ_WRITE`, `MEM_WRITE_ONLY`, or `MEM_READ_ONLY`</li>
          <li>`INVALID_VALUE` -- if `memFlags` is not compatible with the `memFlags` of this WebCLBuffer</li>
          <li>`INVALID_VALUE` -- if <code>sizeInBytes == 0</code></li>
          <li>`INVALID_VALUE` -- if the region specified by (`origin`, `sizeInBytes`) is out of bounds in this WebCLBuffer</li>
          <li>`MISALIGNED_SUB_BUFFER_OFFSET` -- if there is any
            WebCLDevice in the WebCLContext associated with this
            WebCLBuffer for which the given `origin` value would
            result in an improperly aligned sub-buffer</li>
        </ul>

      </dd>
    </dl>

 <!-- ======================================================================================================= -->

    <h4><a id="WEBCLIMAGE">WebCLImage</a></h4>

    <p>
    </p>

<pre class="idl">interface <dfn>WebCLImage</dfn> : WebCLMemoryObject {
  WebCLImageDescriptor getInfo();
};
</pre>

   <dl class="methods">
     <dt class="idl-code">WebCLImageDescriptor getInfo()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=97">OpenCL 1.1 §5.3.6</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetImageInfo.html">clGetImageInfo</a>)</span>
      </dt>
     <dd>
       Returns a new WebCLImageDescriptor containing information about
       the pixel format and dimensions of this WebCLImage.
     </dd>

   </dl>


<!-- ======================================================================================================= -->

    <h3><a id="WEBCLSAMPLER">WebCLSampler</a></h3>

    <p>
    </p>
    <pre class="idl">
interface <dfn>WebCLSampler</dfn> {
  any getInfo(CLenum name);
  void release();
};
</pre>

    <dl class="methods">
      <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=108">OpenCL 1.1 §5.5.2</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetSamplerInfo.html">clGetSamplerInfo</a>)</span>
      </dt>
      <dd>
        <table class="enumtable">
          <tr><th>name</th><th>return type</th></tr>
          <tr><td>SAMPLER_CONTEXT</td><td>WebCLContext</td></tr>
          <tr><td>SAMPLER_NORMALIZED_COORDS</td><td>CLboolean</td></tr>
          <tr><td>SAMPLER_ADDRESSING_MODE</td><td>CLenum</td></tr>
          <tr><td>SAMPLER_FILTER_MODE</td><td>CLenum</td></tr>
        </table>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if `name` is not one of the valid enumerated values listed in the table above</li>
        </ul>
      </dd>

      <dt class="idl-code">void release()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=107">OpenCL 1.1 §5.5.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clReleaseSampler.html">clReleaseSampler</a>)</span>
      </dt>
      <dd>
        Releases the resources held up by this object.
      </dd>
    </dl>

<!-- ======================================================================================================= -->
    <h3><a id="WEBCLPROGRAM">WebCLProgram</a></h3>

    <p>
    </p>
    <pre class="idl">
interface <dfn>WebCLProgram</dfn> {
  any getInfo(CLenum name);

  any getBuildInfo(WebCLDevice device, CLenum name);

  void build(optional sequence&lt;WebCLDevice&gt;? devices = null,
             optional DOMString? options = null,
             optional WebCLCallback whenFinished);

  WebCLKernel createKernel(DOMString kernelName);

  sequence&lt;WebCLKernel&gt; createKernelsInProgram();

  void release();
};
</pre>

    <dl class="methods">
      <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=119">OpenCL 1.1 §5.6.5</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetProgramInfo.html">clGetProgramInfo</a>)</span>
      </dt>
      <dd>
        <table class="enumtable">
          <tr><th>name</th><th>return type</th></tr>
          <tr><td>PROGRAM_CONTEXT</td><td>WebCLContext</td></tr>
          <tr><td>PROGRAM_NUM_DEVICES</td><td>CLuint</td></tr>
          <tr><td>PROGRAM_DEVICES</td><td>sequence&lt;WebCLDevice&gt;</td></tr>
          <tr><td>PROGRAM_SOURCE</td><td>DOMString</td></tr>
        </table>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if `name` is not one of the valid enumerated values listed in the table above</li>
        </ul>
      </dd>

      <dt class="idl-code">any getBuildInfo(WebCLDevice device, CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=122">OpenCL 1.1 §5.6.5</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetProgramBuildInfo.html">clGetProgramBuildInfo</a>)</span>
      </dt>
      <dd>
        <table class="enumtable">
          <tr><th>name</th><th>return type</th></tr>
          <tr><td>PROGRAM_BUILD_STATUS</td><td>CLint</td></tr>
          <tr><td>PROGRAM_BUILD_OPTIONS</td><td>DOMString</td></tr>
          <tr><td>PROGRAM_BUILD_LOG</td><td>DOMString</td></tr>
        </table>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_DEVICE` -- if `device` is not associated with this WebCLProgram</li>
          <li>`INVALID_VALUE` -- if `name` is not one of the valid enumerated values listed in the table above</li>
        </ul>
      </dd>

      <dt class="idl-code">void build(optional sequence&lt;WebCLDevice&gt;? devices = null,
                                      optional DOMString? options = null,
                                      optional WebCLCallback whenFinished)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=114">OpenCL 1.1 §5.6.2</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clBuildProgram.html">clBuildProgram</a>)</span>
      </dt>

      <dd>
        <p>
          Compiles this WebCLProgram for the given list of devices, or in absence of the list, for
          all devices associated with the WebCLContext that this WebCLProgram was created from.  A
          string of compiler options and an asynchronous callback function to invoke when the build
          is completed can also be provided.  Applications are strongly advised to provide a
          callback, to avoid blocking the JavaScript main thread.  The available compiler options
          are listed in the table below; any other option is considered invalid.
        </p>

        <table class="enumtable">
          <tr><th>Build option</th><th>Description</th></tr>
          <tr><td><i>-D name</i></td><td>Equivalent to <i>#define name</i> in OpenCL C.</td></tr>
          <tr><td><i>-D name=definition</i></td><td>Equivalent to <i>#define name definition</i> in OpenCL C.</td></tr>
          <tr><td><i>-cl-opt-disable</i></td><td>Disable all optimizations.</td></tr>
          <tr><td><i>-cl-single-precision-constant</i></td><td>Treat double-precision constants as single-precision.</td></tr>
          <tr><td><i>-cl-denorms-are-zero</i></td><td>Allow denormalized numbers to be flushed to zero.</td></tr>
          <tr><td><i>-cl-mad-enable</i></td><td>Allow <i>a*b+c</i> to be computed with potentially reduced accuracy.</td></tr>
          <tr><td><i>-cl-no-signed-zeros</i></td><td>Allow optimizations that ignore the signedness of zero.</td></tr>
          <tr><td><i>-cl-unsafe-math-optimizations</i></td><td>Allow
              optimizations that may violate IEEE 754 and OpenCL
              numerical compliance requirements. This option
              includes <i>-cl-no-signed-zeros</i>
              and <i>cl-mad-enable</i>.</td></tr>
          <tr><td><i>-cl-finite-math-only</i></td><td>Allow
              optimizations that ignore NaNs and infinities.</td></tr>
          <tr><td><i>-cl-fast-relaxed-math</i></td><td>Equivalent
              to <i>-cl-finite-math-only</i>
              and <i>-cl-unsafe-math-optimizations</i>.</td></tr>
          <tr><td><i>-w</i></td><td>Inhibit all warning messages.</td></tr>
          <tr><td><i>-Werror</i></td><td>Make all warnings into errors.</td></tr>
        </table>

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if <code>devices.length === 0</code></li>
          <li>`INVALID_DEVICE` -- if any element in `devices` is not a valid WebCLDevice</li>
          <li>`INVALID_DEVICE` -- if any device in `devices` is not associated with the WebCLContext of this WebCLProgram</li>
          <li>`INVALID_BUILD_OPTIONS` -- if the build options specified by `options` are invalid</li>
          <li>`BUILD_PROGRAM_FAILURE` -- if there is a failure to build the program executable</li>
          <li>`INVALID_OPERATION` -- if a previous build of this WebCLProgram for any of the devices
            listed in `devices` has not completed</li>
          <li>`INVALID_OPERATION` -- if there are WebCLKernel objects already attached to this
            WebCLProgram</li>
          <li>`INVALID_OPERATION` -- if the blocking form of this function is called from a WebCLCallback</li>
        </ul>
      </dd>

      <dt class="idl-code">WebCLKernel createKernel(DOMString kernelName)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=124">OpenCL 1.1 §5.7.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateKernel.html">clCreateKernel</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_PROGRAM_EXECUTABLE` -- if there is no successfully built executable for any device in this WebCLProgram</li>
          <li>`INVALID_KERNEL_NAME` -- if a kernel by the given `kernelName` is not found in this WebCLProgram</li>
          <li>`INVALID_KERNEL_DEFINITION` -- if the function
            definition of the given kernel function (`kernelName`), such as
            the number of arguments and the argument types, are not
            the same for all devices for which the program executable
            has been built</li>
        </ul>
      </dd>

      <dt class="idl-code">sequence&lt;WebCLKernel&gt; createKernelsInProgram()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=125">OpenCL 1.1 §5.7.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clCreateKernelsInProgram.html">clCreateKernelsInProgram</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_PROGRAM_EXECUTABLE` -- if there is no successfully built executable for any device in this WebCLProgram</li>
        </ul>
      </dd>

      <dt class="idl-code">void release()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=113">OpenCL 1.1 §5.6.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clReleaseProgram.html">clReleaseProgram</a>)</span>
      </dt>
      <dd>
      <dd>
        Releases the resources held up by this object.
      </dd>

    </dl>

<!-- ======================================================================================================= -->

    <h3><a id="WEBCLKERNEL">WebCLKernel</a></h3>

    <p>
      The following methods are available for setting kernel arguments
      and querying kernel-specific information.
    </p>

<pre class="idl">
interface <dfn>WebCLKernel</dfn> {
  any getInfo(CLenum name);
  any getWorkGroupInfo(WebCLDevice? device, CLenum name);
  WebCLKernelArgInfo getArgInfo(CLuint index);
  void setArg(CLuint index, WebCLBuffer buffer);
  void setArg(CLuint index, WebCLImage image);
  void setArg(CLuint index, WebCLSampler value);
  void setArg(CLuint index, ArrayBufferView value);
  void release();
};
</pre>

    <dl class="methods">
      <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=129">OpenCL 1.1 §5.7.3</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetKernelInfo.html">clGetKernelInfo</a>)</span>
      </dt>
      <dd>
        <table class="enumtable">
          <tr><th>name</th><th>return type</th></tr>
          <tr><td>KERNEL_FUNCTION_NAME</td><td>DOMString</td></tr>
          <tr><td>KERNEL_NUM_ARGS</td><td>CLuint</td></tr>
          <tr><td>KERNEL_CONTEXT</td><td>WebCLContext</td></tr>
          <tr><td>KERNEL_PROGRAM</td><td>WebCLProgram</td></tr>
        </table>

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if `name` is not one of the valid enumerated values listed in the table above</li>
        </ul>
      </dd>

      <dt class="idl-code">any getWorkGroupInfo(WebCLDevice? device, CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=130">OpenCL 1.1 §5.7.3</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetKernelWorkGroupInfo.html">clGetKernelWorkGroupInfo</a>)</span>
      </dt>
      <dd>
        <p>
          Returns the value corresponding to the given `device` and `name`.  If there is only a
          single WebCLDevice associated with this WebCLKernel, `null` may be passed for `device`.
        </p>

        <table class="enumtable">
          <tr><th>name</th><th>return type</th></tr>
          <tr><td>KERNEL_WORK_GROUP_SIZE</td><td>CLuint</td></tr>
          <tr><td>KERNEL_COMPILE_WORK_GROUP_SIZE</td><td>sequence&lt;CLuint&gt;</td></tr>
          <tr><td>KERNEL_LOCAL_MEM_SIZE</td><td>CLuint</td></tr>
          <tr><td>KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE</td><td>CLuint</td></tr>
          <tr><td>KERNEL_PRIVATE_MEM_SIZE</td><td>CLuint</td></tr>
        </table>

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_DEVICE` -- if `device` is not associated with this WebCLKernel</li>
          <li>`INVALID_DEVICE` -- if `device` is `null` but there is more than one WebCLDevice associated with this WebCLKernel</li>
          <li>`INVALID_VALUE` -- if `name` is not one of the valid enumerated values listed in the table above</li>
        </ul>
      </dd>


      <dt class="idl-code">WebCLKernelArgInfo getArgInfo(CLuint index)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.2.pdf#page=167">OpenCL 1.2 §5.7.3</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clGetKernelArgInfo.html">clGetKernelArgInfo</a>)</span>
      </dt>
      <dd>
        Retrieves the name, type, and qualífiers of the kernel argument at the given `index`.  Legal
        values for `index` range from zero to `N-1`, where `N` is the total number of arguments
        declared by the kernel.

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_ARG_INDEX` -- if `index` is not a valid argument index for this WebCLKernel</li>
        </ul>
      </dd>

      <dt class="idl-code">void setArg(CLuint index, WebCLBuffer buffer)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.7.2">OpenCL 1.1 §5.7.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clSetKernelArg.html">clSetKernelArg</a>)</span>
      </dt>
      <dd>
        <p>
          Sets the given `buffer` to the kernel argument at the given `index`.  Legal values for
          `index` range from zero to `N-1`, where `N` is the total number of arguments declared by
          the kernel.
        </p>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_ARG_INDEX` -- if `index` is not a valid argument index for this WebCLKernel</li>
          <li>`INVALID_ARG_VALUE` -- if the expected kernel argument at `index` is not a WebCLBuffer</li>
          <li>`INVALID_MEM_OBJECT` -- if `buffer` is not a valid WebCLBuffer</li>
        </ul>
      </dd>

      <dt class="idl-code">void setArg(CLuint index, WebCLImage image)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.7.2">OpenCL 1.1 §5.7.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clSetKernelArg.html">clSetKernelArg</a>)</span>
      </dt>
      <dd>
        <p>
          Sets the given `image` to the kernel argument at the given `index`.  Legal values for
          `index` range from zero to `N-1`, where `N` is the total number of arguments declared by
          the kernel.
        </p>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_ARG_INDEX` -- if `index` is not a valid argument index for this WebCLKernel</li>
          <li>`INVALID_ARG_VALUE` -- if the expected kernel argument at `index` is not a WebCLImage</li>
          <li>`INVALID_MEM_OBJECT` -- if `image` is not a valid WebCLImage</li>
        </ul>
      </dd>

      <dt class="idl-code">void setArg(CLuint index, WebCLSampler sampler)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.7.2">OpenCL 1.1 §5.7.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clSetKernelArg.html">clSetKernelArg</a>)</span>
      </dt>
      <dd>
        <p>
          Sets the given `sampler` to the kernel argument at the given `index`.  Legal values for
          `index` range from zero to `N-1`, where `N` is the total number of arguments declared by
          the kernel.
        </p>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_ARG_INDEX` -- if `index` is not a valid argument index for this WebCLKernel</li>
          <li>`INVALID_ARG_VALUE` -- if the expected kernel argument at `index` is not a WebCLSampler</li>
          <li>`INVALID_SAMPLER` -- if `sampler` is not a valid WebCLSampler</li>
        </ul>
      </dd>

      <dt class="idl-code">void setArg(CLuint index, ArrayBufferView value)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.7.2">OpenCL 1.1 §5.7.2</a>,
        <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clSetKernelArg.html">clSetKernelArg</a>)</span>
      </dt>
      <dd>
        <p>
          Sets the given `value` to the kernel argument at the given
          `index`.  Legal values for `index` range from zero to `N-1`,
          where `N` is the total number of arguments declared by the
          kernel.
        </p>
        <p>
          The type and length of `value` must match the base type and
          vector width of the target kernel argument. For example, if
          the kernel argument is of type `float4`, then `value` must
          be a Float32Array of length 4.  Arguments with the `local`
          address space qualifier must be set using a Uint32Array of
          length 1, specifying the number of bytes to be allocated.
        </p>
        <p>
          Since there is no 64-bit integer variant of ArrayBufferView,
          64-bit integers must be represented as pairs of 32-bit
          unsigned integers. The low-order 32 bits are stored in the
          first element of each pair, and the high-order 32 bits in
          the second element.
        </p>

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_ARG_INDEX` -- if `index` is not a valid argument index for this WebCLKernel</li>
          <li>`INVALID_ARG_VALUE` -- if the expected kernel argument at `index` is not a scalar, vector, or local memory size</li>
          <li>`INVALID_ARG_VALUE` -- if the kernel argument at `index` has the `local` address space
            qualifier, and `value` is not a Uint32Array of length 1</li>
          <li>`INVALID_ARG_VALUE` -- if the type of `value` does not match the base type of the kernel argument at `index`</li>
          <li>`INVALID_ARG_SIZE` -- if `value.length` is not 1, 2, 3, 4, 8, 16, or 32</li>
          <li>`INVALID_ARG_SIZE` -- if `value.length` is not equal to the vector width of the kernel argument at `index`,
                                    or twice the vector width in case of a 64-bit integer argument</li>
          <li>`INVALID_ARG_SIZE` -- if the kernel argument at `index` has the `local` address space
            qualifier, and `value[0]` is not greater than zero</li>
        </ul>
      </dd>

      <dt class="idl-code">void release()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=126">OpenCL 1.1 §5.7.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clReleaseKernel.html">clReleaseKernel</a>)</span>
      </dt>
      <dd>
        Releases the resources held up by this object.
      </dd>

    </dl>

<pre class="example">
myKernel.setArg(0, 3.14159);                                  // ERROR: Passing in a Number is not allowed
myKernel.setArg(0, new Float32Array([3.14159]));              // cast 3.14159 to `float`, then pass to kernel as arg #0
myKernel.setArg(1, new Uint32Array([1.23, 2.34]));            // cast the numbers to `uint2`, then pass to kernel as arg #1
myKernel.setArg(2, new Uint32Array([512]));                   // reserve 512 bytes of local memory for arg #2
myKernel.setArg(3, myImage);                                  // pass `myImage` to kernel as arg #3
</pre>

<!-- ======================================================================================================= -->

    <h4><a id="WEBCLKERNELARGINFO">WebCLKernelArgInfo</a></h4>

    <p>
    </p>

<pre class="idl">
dictionary <dfn>WebCLKernelArgInfo</dfn> {
  DOMString name;
  DOMString typeName;         // 'char', 'float', 'uint4', 'image2d_t', 'sampler_t', etc.
  DOMString addressQualifier; // 'global', 'local', 'constant', or 'private'
  DOMString accessQualifier;  // 'read_only', 'write_only', or 'none'
};
</pre>

    <dl class="methods">

      <dt class="idl-code">DOMString name</dt>
      <dd>
        The name of the kernel argument; for example, <i>srcPixels</i> or <i>foobarCoefficient</i>.
      </dd>

      <dt class="idl-code">DOMString typeName
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-6.1">OpenCL 1.1 §6.1</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/dataTypes.html">Data types</a>)</span>
      </dt>
      <dd>
        The data type of the kernel argument in normalized form; for example, <i>uint4</i> or
        <i>image2d_t</i>.
      </dd>

      <dt class="idl-code">DOMString addressQualifier
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-6.5">OpenCL 1.1 §6.5</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/constant.html">Address space qualifiers</a>)</span>
      </dt>
      <dd>
        The address space qualifier of the kernel argument in normalized form (that is, not prefixed
        with underscores). The possible values are <i>global</i>, <i>local</i>, <i>constant</i>,
        and <i>private</i>.
      </dd>

      <dt class="idl-code">DOMString accessQualifier
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-6.6">OpenCL 1.1 §6.6</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/accessQualifiers.html">Access qualifiers</a>)</span>
      </dt>
      <dd>
        The access qualifier of the kernel argument in normalized form (that is, not prefixed with
        underscores). If `typeName` is <i>image2d_t</i>, the possible values are <i>read_only</i>
        and <i>write_only</i>. Otherwise, the value is <i>none</i>.
      </dd>

    </dl>

<!-- ======================================================================================================= -->

    <h3><a id="WEBCLEVENT">WebCLEvent</a></h3>

    <p>
    </p>

<pre class="idl">
[Constructor]
interface <dfn>WebCLEvent</dfn> {
  any getInfo(CLenum name);
  CLulong getProfilingInfo(CLenum name);
  void setCallback(CLenum commandExecCallbackType, WebCLCallback notify);
  void release();
};
</pre>

    <dl class="methods">
      <dt class="idl-code">WebCLEvent()
      </dt>
      <dd>
        <p>
          Creates an empty WebCLEvent instance, to be populated by one of the `enqueue` methods.
          Each WebCLEvent instance can only be used once; the `enqueue` methods will throw an
          `INVALID_EVENT` exception if a previously populated event is passed in.  User events are
          considered to be populated by `createUserEvent`, and as such cannot be re-populated.
        </p>
      </dd>

      <dt class="idl-code">any getInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.9">OpenCL 1.1 §5.9</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetEventInfo.html">clGetEventInfo</a>)</span>
      </dt>
      <dd>
        <table class="enumtable">
          <tr><th>name</th><th>return type</th></tr>
          <tr><td>EVENT_COMMAND_QUEUE</td><td>WebCLCommandQueue</td></tr>
          <tr><td>EVENT_CONTEXT</td><td>WebCLContext</td></tr>
          <tr><td>EVENT_COMMAND_TYPE</td><td>CLenum</td></tr>
          <tr><td>EVENT_COMMAND_EXECUTION_STATUS</td><td>CLint</td></tr>
        </table>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if `name` is not one of the valid enumerated values listed in the table above</li>
          <li>`INVALID_EVENT` -- if this WebCLEvent has not yet been populated</li>
        </ul>
      </dd>

      <dt class="idl-code">any getProfilingInfo(CLenum name)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.12">OpenCL 1.1 §5.12</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetEventProfilingInfo.html">clGetEventProfilingInfo</a>)</span>
      </dt>
      <dd>
        <table class="enumtable">
          <tr><th>name</th><th>return type</th></tr>
          <tr><td>PROFILING_COMMAND_QUEUED</td><td>CLulong</td></tr>
          <tr><td>PROFILING_COMMAND_SUBMIT</td><td>CLulong</td></tr>
          <tr><td>PROFILING_COMMAND_START</td><td>CLulong</td></tr>
          <tr><td>PROFILING_COMMAND_END</td><td>CLulong</td></tr>
        </table>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`PROFILING_INFO_NOT_AVAILABLE` -- if the `QUEUE_PROFILING_ENABLE` flag is not set for this WebCLCommandQueue</li>
          <li>`PROFILING_INFO_NOT_AVAILABLE` -- if the execution status of this WebCLEvent is not `COMPLETE`</li>
          <li>`PROFILING_INFO_NOT_AVAILABLE` -- if this WebCLEvent is a user event object</li>
          <li>`INVALID_VALUE` -- if `name` is not one of the valid enumerated values listed in the table above</li>
          <li>`INVALID_EVENT` -- if this WebCLEvent has not yet been populated</li>
        </ul>
      </dd>

      <dt class="idl-code">void setCallback(CLenum commandExecCallbackType, WebCLCallback notify)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.9">OpenCL 1.1 §5.9</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clSetEventCallback.html">clSetEventCallback</a>)</span>
      </dt>
      <dd>
        Sets a WebCLCallback function `notify` to be called when this
        WebCLEvent reaches the given `commandExecCallbackType` status
        (`COMPLETE`, `RUNNING`, `SUBMITTED`, or `QUEUED`). In this
        version of WebCL, only the `COMPLETE` status is supported.

        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if `commandExecCallbackType` is not `COMPLETE`</li>
          <li>`INVALID_EVENT` -- if this WebCLEvent has not yet been populated</li>
        </ul>
      </dd>

      <dt class="idl-code">void release()
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#page=149">OpenCL 1.1 §5.9</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clReleaseEvent.html">clReleaseEvent</a>)</span>
      </dt>
      <dd>
        Releases the resources held up by this object.
      </dd>

    </dl>

<!-- ======================================================================================================= -->

    <h4><a id="WEBCLUSEREVENT">WebCLUserEvent</a></h4>

    <p>
    </p>

<pre class="idl">
interface <dfn>WebCLUserEvent</dfn> : WebCLEvent {
  void  setStatus(CLint executionStatus);
};
</pre>

    <dl class="methods">
      <dt class="idl-code">void setStatus(CLint executionStatus)
        <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf#nameddest=section-5.9">OpenCL 1.1 §5.9</a>,
          <a class="nonnormative" href="http://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clSetUserEventStatus.html">clSetUserEventStatus</a>)</span>
      </dt>
      <dd>
        <h5 class="exceptions">Exceptions:</h5>
        <ul class="exceptions">
          <li>`INVALID_VALUE` -- if `executionStatus` is not `COMPLETE` or a negative integer value</li>
          <li>`INVALID_OPERATION` -- if the execution status of this
            event has already been changed by a previous call to
            `setStatus`</li>
        </ul>
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h2>Extensions</h2>

    <p>
      WebCL implementations may expose a number of extensions to the core functionality.  The
      extensions are listed and documented in
      the <a href="http://www.khronos.org/registry/webcl/extensions/">WebCL Extension Registry</a>.
      Each extension, regardless of its standardization status, must be explicitly enabled by the
      application before it can be used.  This policy is aimed to minimize inadvertant usage of
      features that are not universally available.
    </p>
    
    <p>
      The set of available extensions may vary from one WebCLDevice to
      another, and one WebCLPlatform to another, even within the same
      system.  For example, the WebGL Resource Sharing extension may
      be supported by the GPU but not the CPU.  The names of
      extensions that are supported system-wide can be queried with
      `webcl.getSupportedExtensions()`.  Similarly, calling
      `getSupportedExtensions` on a particular WebCLPlatform returns
      the set of extensions that are supported by all devices on that
      platform.  Finally, `getSupportedExtensions()` on an individual
      WebCLDevice returns the set of extensions that are supported by
      that device.
    </p>

    <p>
      WebCL extensions can be enabled by calling `enableExtension`
      with the name of the desired extension as a string parameter.
      This returns `true` if the extension is successfully enabled,
      and `false` if not.  This is illustrated in the following
      examples.
    </p>

<pre class="example">
// Iterates over all WebCL devices and returns the ones that
// support the given extension, with that extension enabled.
//
function getDevicesWithExtensionEnabled(extensionName) {
  var devices = [];
  webcl.getPlatforms().forEach(function(platform) {
    platform.getDevices().forEach(function(device) {
      var isSupported = device.enableExtension(extensionName);
      if (isSupported) devices.push(device);
    });
  });
  return devices;
}
</pre>

<pre class="example">
// Use the above function find the set of devices
// that support both KHR_fp64 and KHR_gl_sharing.
//
var withFP64 = getDevicesWithExtensionEnabled("KHR_fp64");
var withGL = getDevicesWithExtensionEnabled("KHR_gl_sharing");
var withBoth = withGL.filter(function(v) { return (withFP64.indexOf(v) !== -1) });
</pre>

<!-- ======================================================================================================= -->

    <h2>Security and Robustness</h2>

    <p>
      WebCL has been designed with security as a primary concern.  This section defines the main
      security requirements that a conformant WebCL implementation must fulfill.

    <h3>Out-of-Bounds Memory Access</h3>

    <p>
      WebCL kernels must not be able to access unauthorized areas of memory, regardless of address
      space (private, local, global, or constant).  If detected during compilation, out-of-bounds
      (OOB) accesses must generate a compiler error.  At runtime, OOB reads must return zero and
      writes must be discarded.  Alternatively, the kernel may be terminated and an exception be
      thrown.
    </p>

    <p>
      For purposes of bounds checking, the implementation may treat all `private` variables as one
      contiguous block of memory, and similarly for `local` variables, instead of enforcing the
      bounds of each variable separately.  For example, in a kernel program containing two `private`
      arrays, an OOB read from the first array is allowed to return any value from either the first
      or the second array, rather than zero.
    </p>

    <p>
      The WebCL Validator open source project was initiated by the WebCL working group for
      prevention of out-of-bounds memory accesses through instrumentation, analysis and validation
      of WebCL kernels.  The Validator also enforces initialization of local and private memory
      <span class="cl-spec">(<a href="https://github.com/KhronosGroup/webcl-validator">Khronos WebCL
      Validator Project</a>)</span>.
    </p>

    <h3>Memory Initialization</h3>

    <p>
      To ensure that applications cannot inspect data left behind by previous applications, the
      WebCL implementation must initialize all buffers and variables to zero before giving the
      application read access to them.  This requirement applies regardless of address space
      (private, local, global, or constant), and regardless of whether the allocation is made in
      kernel code or host code.
    </p>

    <p>
      Where available, the OpenCL 1.2 extension `cl_khr_initialize_memory` allows WebCL
      implementations to automatically and efficiently initialize local and private memory before a
      kernel begins execution
      <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.2-extensions.pdf#page=131">OpenCL
      1.2 Extensions Specification, §9.15</a>)</span>.
    </p>

    <h3>Denial of Service</h3>

    <p>
      Long-running and/or computationally intensive kernels (or other commands in a command queue)
      may cause the system to become unresponsive by disproportionately consuming device resources.
      It is generally not possible to guard against this problem at the browser/WebCL level; the
      necessary mechanisms, such as watchdog timers and pre-emptive multitasking, must be provided
      by the OpenCL driver and the operating system.  On systems where the necessary facilities are
      in place, WebCL implementations are strongly encouraged to make use of them in order to:

    <ol>
      <li>Detect offending kernels and other commands.  A command is considered offending if it runs
        for an excessively long time, or disproportionately consumes system resources.</li>
      <li>Terminate the contexts associated with the offending commands, before they render the
        OpenCL device unresponsive, and result in potential device reset.</li>
    </ol>
   
    <p>
      Where available, the OpenCL 1.2 extension `cl_khr_terminate_context` can be used for fast
      termination of a context, if, for example, one or more of the kernels associated with the
      context has been running too long, or if the program terminates due to an exception
      <span class="cl-spec">(<a href="http://www.khronos.org/registry/cl/specs/opencl-1.2-extensions.pdf#page=132">OpenCL
      1.2 Extensions Specification, §9.16</a>)</span>.
    </p>
<!-- ======================================================================================================= -->

    <h2>Implementation notes</h2>

    <p>
      Although WebCL is based on OpenCL 1.1 (Embedded Profile), it can also be implemented on top of
      OpenCL 1.2, or any future version that remains backwards compatible with OpenCL 1.1.  However,
      an implementation running on top of OpenCL 1.2 or later must make sure to not allow
      applications to use any features that are not supported in WebCL.  This implies, in
      particular, that implementations must not pass kernel code to the underlying OpenCL compiler
      without first checking that the kernel code is valid according to WebCL.  For example, usage
      of `printf()` must be treated as a compilation error, because `printf` is not supported in
      WebCL.
    </p>

    <p>
      The WebCL specification and conformance tests are written with
      the assumption that implementations will be based on conformant
      OpenCL drivers.  Implementations are strongly recommended to
      support dynamic black-listing of malfunctioning or vulnerable
      OpenCL drivers in order to quickly eliminate any security or
      stability issues.
    </p>

    <p>
      WebCL objects are regular JavaScript objects, and must behave accordingly.  For example, the
      application must be able attach arbitrary properties and functions to them, and if the same
      object is retrieved twice, the instances returned must be equal according to the `===`
      operator.  For example, the assertions in the following code example must be true:
    </p>

<pre class="example">
  var ctx = webcl.createContext();
  ctx.name = "myContext";
  var queue = ctx.createCommandQueue();
  var ctx2 = queue.getInfo(WebCL.QUEUE_CONTEXT);
  ASSERT(ctx2 === ctx);
  ASSERT(ctx2.name === "myContext");
</pre>

    <h2><a id="WEBCL_OPENCL_DIFF">Differences between WebCL and OpenCL 1.1</a></h2>

    <p>
      This section describes changes made to the WebCL API and the WebCL C kernel programming
      language, relative to OpenCL 1.1 Embedded Profile and OpenCL C.  The differences are as
      follows:
    </p>

    <ul>
      <li>2D image support is required</li>
      <li>3D images are not supported</li>
      <li>The `ADDRESS_NONE` sampler addressing mode is not supported</li>
      <li>Mapping of CL memory objects into host memory space is not supported</li>
      <li>Program binaries are not supported</li>
      <li>The following OpenCL API functions are not supported:
        <ul>
          <li>`clEnqueueTask`</li>
          <li>`clEnqueueNativeKernel`</li>
          <li>`clCreateImage3D`</li>
          <li>`clCreateProgramWithBinary`</li>
          <li>`clEnqueueMapBuffer`</li>
          <li>`clEnqueueMapImage`</li>
          <li>`clEnqueueUnmapMemObject`</li>
          <li>`clSetMemObjectDestructorCallback`</li>
          <li>`clUnloadCompiler`</li>
        </ul>
      </li>
      <li>Structures are not supported as kernel arguments</li>
      <li>Calling a kernel function from another kernel function is not supported</li>
      <li>Identifiers in WebCL C must be less than 256 characters</li>
      <li>The `goto` keyword is not supported</li>
      <li>The following OpenCL C built-in functions and are not supported:
        <ul>
          <li>`async_work_group_copy`</li>
          <li>`async_work_group_strided_copy`</li>
          <li>`wait_group_events`</li>
        </ul>
      </li>
    </ul>
    
<!-- ======================================================================================================= -->

    <h2>References</h2>

    <h3>Normative references</h3>

    <dl>
      <dt id="refsOPENCL">[OPENCL11]</dt>
      <dd><cite><a href="http://www.khronos.org/registry/cl/specs/opencl-1.1.pdf">
            OpenCL 1.1 Specification</a></cite>,
        A. Munshi.
      </dd>
      <dt id="refsWEBIDL">[WEBIDL]</dt>
      <dd><cite><a href="http://www.w3.org/TR/WebIDL/">
            Web IDL: W3C Candidate Recommendation</a></cite>,
        C. McCormack.
      </dd>
      <dt id="refsWEBGL">[WEBGL]</dt>
      <dd><cite><a href="https://www.khronos.org/registry/webgl/specs/1.0/">
            WebGL 1.0 Specification</a></cite>,
        C. Marrin.
      </dd>
    </dl>

<!-- ======================================================================================================= -->

    <h2>Acknowledgments</h2>
    <p>This specification is produced by the Khronos WebCL Working Group.</p>

	  <dt>Main Contributors (in alphabetical order):</dt>
    <dd> Tomi Aarnio (Editor)</dd>
    <dd> Alex Bourd </dd>
    <dd>Mika&euml;l Bourges-S&eacute;venier (Editor)</a>
    <dd> Tasneem Brutch (Working Group Chair)</dd>
    <dd> Fabien Cellier</dd>
    <dd> Steven Eliuk</dd>
    <dd> Simon Gibbs </dd>
    <dd> Jeff Gilbert </dd>
    <dd> Antonio Gomes </dd>
    <dd> Won Jeon </dd>
    <dd> Tim Johansson </dd>
    <dd> Sharath Kamath </dd>
    <dd> David Ligon </dd>
    <dd> Laurent Morichetti </dd>
    <dd> Igor Oliveira </dd>
    <dd> Amit Rao </dd>
    <dd> Ofer Rosenberg </dd>
    <dd> Dave Shreiner </dd>
    <dd> Shilpa Shri </dd>
    <dd> Neil Trevett </dd>

    <dd> </dd>

	  <dt>Additional Contributors and Participants (in alphabetical order):</dt>
    <dd> Remi Arnaud </dd>
    <dd> Andrew Brownsword </dd>
    <dd> Robert Elliott </dd>
    <dd> Stephen Frye </dd>
    <dd> Rick Hudson </dd>
    <dd> Adam Lake </dd>
    <dd> Thierry Lepley </dd>
    <dd> Bill Licea-Kane </dd>
    <dd> Mikael Lepisto </dd>
    <dd> Anthony Liot </dd>
    <dd> Aaftab Munshi </dd>
    <dd> Jari Nikara </dd>
    <dd> Janne Pietiäinen </dd>
    <dd> Andrew Richards </dd>
    <dd> Kenneth Russell </dd>
    <dd> Dirk Schulze </dd>
    <dd> Micah Villmow </dd>
    <dd> Rami Ylimaki </dd>
    <dd> Gongyuan Zhuang </dd>

    <dd> </dd>

    
    <dt>Special thanks to the following participants (in alphabetical order):</dt>
    <dd> Bastiaan Aarts </dd>
    <dd> Ben Ashbaugh </dd>
    <dd> Mark Callow </dd>
    <dd> Sean Ellis </dd>
    <dd> Anwar Ghuloum </dd>
    <dd> Pyry Haulos </dd>
    <dd> Dean Jackson </dd>
    <dd> Benoit Jacob </dd>
    <dd> Seungwon Lee </dd>
    <dd> Erik Moller </dd>
    <dd> Matthew Newport </dd>
    <dd> Eisaku Ohbuchi </dd>
    <dd> Rob Quill </dd>
    <dd> Kalle Raita </dd>
    <dd> Antti Rasmus </dd>
    <dd> Lars Remes </dd>
    <dd> Larry Seiler </dd>
    <dd> Tatiana Shpeisman </dd>
    <dd> Kevin Smith </dd>
    <dd> Gowtham Tammana </dd>
    <dd> Thierry Vuillaume </dd>
    <dd> Todd Weybrew </dd>
    <dd> Dong-Hoon Yoo </dd>
</body>
</html>
